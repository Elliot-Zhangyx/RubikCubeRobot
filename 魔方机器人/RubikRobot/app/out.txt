\n
./src/androidTest//java//com//example//rubikrobot//ExampleInstrumentedTest.java
\n
package com.example.rubikrobot;

import android.content.Context;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.ext.junit.runners.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import static org.junit.Assert.*;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
    @Test
    public void useAppContext() {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
        assertEquals("com.example.rubikrobot", appContext.getPackageName());
    }
}\n
./src/main//java//com//example//rubikrobot//Bluetooth//BluetoothChatService.java
\n
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.rubikrobot.Bluetooth;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothServerSocket;
import android.bluetooth.BluetoothSocket;
import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;

import com.example.rubikrobot.MainActivity;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.UUID;

/**
 * This class does all the work for setting up and managing Bluetooth
 * connections with other devices. It has a thread that listens for
 * incoming connections, a thread for connecting with a device, and a
 * thread for performing data transmissions when connected.
 */
public class BluetoothChatService {
    // Debugging
    private static final String TAG = "BluOnetoothChatService";
    private static final boolean D = true;

    // Name for the SDP record when creating server socket
    private static final String NAME = "MainActivity";

    // Unique UUID for this application
    									 				
    private static final UUID MY_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");

    // Member fields
    private final BluetoothAdapter mAdapter;
    private final Handler mHandler;
    private AcceptThread mAcceptThread;
    private ConnectThread mConnectThread;
    private ConnectedThread mConnectedThread;
    private int mState;

    // Constants that indicate the current connection state
    public static final int STATE_NONE = 0;       // we're doing nothing
    public static final int STATE_LISTEN = 1;     // now listening for incoming connections
    public static final int STATE_CONNECTING = 2; // now initiating an outgoing connection
    public static final int STATE_CONNECTED = 3;  // now connected to a remote device

    /**
     * Constructor. Prepares a new MainActivity session.
     * @param context  The UI Activity Context
     * @param handler  A Handler to send messages back to the UI Activity
     */
    public BluetoothChatService(Context context, Handler handler)
    {
        mAdapter = BluetoothAdapter.getDefaultAdapter();
        mState = STATE_NONE;
        mHandler = handler;
    }

    /**
     * Set the current state of the chat connection
     * @param state  An integer defining the current connection state
     */
    private synchronized void setState(int state)
    {
        if (D) Log.d(TAG, "setState() " + mState + " -> " + state);
        mState = state;

        // Give the new state to the Handler so the UI Activity can update
        mHandler.obtainMessage(MainActivity.MESSAGE_STATE_CHANGE, state, -1).sendToTarget();
    }

    /**
     * Return the current connection state. */
    public synchronized int getState() {
        return mState;
    }

    /**
     * Start the chat service. Specifically start AcceptThread to begin a
     * session in listening (server) mode. Called by the Activity onResume() */
    public synchronized void start() {
        if (D) Log.d(TAG, "start");

        // Cancel any thread attempting to make a connection
        if (mConnectThread != null) {mConnectThread.cancel(); mConnectThread = null;}

        // Cancel any thread currently running a connection
        if (mConnectedThread != null) {mConnectedThread.cancel(); mConnectedThread = null;}

        // Start the thread to listen on a BluetoothServerSocket
        if (mAcceptThread == null) {
            mAcceptThread = new AcceptThread();
            mAcceptThread.start();
        }
        setState(STATE_LISTEN);
    }

    /**
     * Start the ConnectThread to initiate a connection to a remote device.
     * @param device  The BluetoothDevice to connect
     */
    public synchronized void connect(BluetoothDevice device) {
        if (D) Log.d(TAG, "connect to: " + device);

        // Cancel any thread attempting to make a connection
        if (mState == STATE_CONNECTING) {
            if (mConnectThread != null) {mConnectThread.cancel(); mConnectThread = null;}
        }

        // Cancel any thread currently running a connection
        if (mConnectedThread != null) {mConnectedThread.cancel(); mConnectedThread = null;}

        // Start the thread to connect with the given device
        mConnectThread = new ConnectThread(device);
        mConnectThread.start();
        setState(STATE_CONNECTING);
    }

    /**
     * Start the ConnectedThread to begin managing a Bluetooth connection
     * @param socket  The BluetoothSocket on which the connection was made
     * @param device  The BluetoothDevice that has been connected
     */
    public synchronized void connected(BluetoothSocket socket, BluetoothDevice device) {
        if (D) Log.d(TAG, "connected");

        // Cancel the thread that completed the connection
        if (mConnectThread != null) {mConnectThread.cancel(); mConnectThread = null;}

        // Cancel any thread currently running a connection
        if (mConnectedThread != null) {mConnectedThread.cancel(); mConnectedThread = null;}

        // Cancel the accept thread because we only want to connect to one device
        if (mAcceptThread != null) {mAcceptThread.cancel(); mAcceptThread = null;}

        // Start the thread to manage the connection and perform transmissions
        mConnectedThread = new ConnectedThread(socket);
        mConnectedThread.start();

        // Send the name of the connected device back to the UI Activity
        Message msg = mHandler.obtainMessage(MainActivity.MESSAGE_DEVICE_NAME);
        Bundle bundle = new Bundle();
        bundle.putString(MainActivity.DEVICE_NAME, device.getName());
        msg.setData(bundle);
        mHandler.sendMessage(msg);

        setState(STATE_CONNECTED);
    }

    /**
     * Stop all threads
     */
    public synchronized void stop() {
        if (D) Log.d(TAG, "stop");
        if (mConnectThread != null) {mConnectThread.cancel(); mConnectThread = null;}
        if (mConnectedThread != null) {mConnectedThread.cancel(); mConnectedThread = null;}
        if (mAcceptThread != null) {mAcceptThread.cancel(); mAcceptThread = null;}
        setState(STATE_NONE);
    }

    /**
     * Write to the ConnectedThread in an unsynchronized manner
     * @param out The bytes to write
     * @see ConnectedThread#write(byte[])
     */
    public void write(byte[] out) {
        // Create temporary object
        ConnectedThread r;
        // Synchronize a copy of the ConnectedThread
        synchronized (this) {
            if (mState != STATE_CONNECTED) return;
            r = mConnectedThread;
        }
        // Perform the write unsynchronized
        System.out.println(out);
        r.write(out);
    }

    /**
     * Indicate that the connection attempt failed and notify the UI Activity.
     */
    private void connectionFailed() {
        setState(STATE_LISTEN);

        // Send a failure message back to the Activity
        Message msg = mHandler.obtainMessage(MainActivity.MESSAGE_TOAST);
        Bundle bundle = new Bundle();
        bundle.putString(MainActivity.TOAST, "不能连接到该设备");
        msg.setData(bundle);
        mHandler.sendMessage(msg);
    }

    /**
     * Indicate that the connection was lost and notify the UI Activity.
     */
    private void connectionLost() {
        setState(STATE_LISTEN);

        // Send a failure message back to the Activity
        Message msg = mHandler.obtainMessage(MainActivity.MESSAGE_TOAST);
        Bundle bundle = new Bundle();
        bundle.putString(MainActivity.TOAST, "设备连接断开");
        msg.setData(bundle);
        mHandler.sendMessage(msg);
    }

    /**
     * This thread runs while listening for incoming connections. It behaves
     * like a server-side client. It runs until a connection is accepted
     * (or until cancelled).
     */
    private class AcceptThread extends Thread {
        // The local server socket
        private final BluetoothServerSocket mmServerSocket;

        public AcceptThread() {
            BluetoothServerSocket tmp = null;

            // Create a new listening server socket
            try {
                tmp = mAdapter.listenUsingRfcommWithServiceRecord(NAME, MY_UUID);
            } catch (IOException e) {
                Log.e(TAG, "listen() failed", e);
            }
            mmServerSocket = tmp;
        }

        public void run() {
            if (D) Log.d(TAG, "BEGIN mAcceptThread" + this);
            setName("AcceptThread");
            BluetoothSocket socket = null;

            // Listen to the server socket if we're not connected
            while (mState != STATE_CONNECTED) {
                try {
                    // This is a blocking call and will only return on a
                    // successful connection or an exception
                    socket = mmServerSocket.accept();
                } catch (IOException e) {
                    Log.e(TAG, "accept() failed", e);
                    break;
                }

                // If a connection was accepted
                if (socket != null) {
                    synchronized (BluetoothChatService.this) {
                        switch (mState) {
                        case STATE_LISTEN:
                        case STATE_CONNECTING:
                            // Situation normal. Start the connected thread.
                            connected(socket, socket.getRemoteDevice());
                            break;
                        case STATE_NONE:
                        case STATE_CONNECTED:
                            // Either not ready or already connected. Terminate new socket.
                            try {
                                socket.close();
                            } catch (IOException e) {
                                Log.e(TAG, "Could not close unwanted socket", e);
                            }
                            break;
                        }
                    }
                }
            }
            if (D) Log.i(TAG, "END mAcceptThread");
        }

        public void cancel() {
            if (D) Log.d(TAG, "cancel " + this);
            try {
                mmServerSocket.close();
            } catch (IOException e) {
                Log.e(TAG, "close() of server failed", e);
            }
        }
    }


    /**
     * This thread runs while attempting to make an outgoing connection
     * with a device. It runs straight through; the connection either
     * succeeds or fails.
     */
    private class ConnectThread extends Thread {
        private final BluetoothSocket mmSocket;
        private final BluetoothDevice mmDevice;

        public ConnectThread(BluetoothDevice device) {
            mmDevice = device;
            BluetoothSocket tmp = null;

            // Get a BluetoothSocket for a connection with the
            // given BluetoothDevice
            try {
                tmp = device.createRfcommSocketToServiceRecord(MY_UUID);
            } catch (IOException e) {
                Log.e(TAG, "create() failed", e);
            }
            mmSocket = tmp;
        }

        public void run() {
            Log.i(TAG, "BEGIN mConnectThread");
            setName("ConnectThread");

            // Always cancel discovery because it will slow down a connection
            mAdapter.cancelDiscovery();

            // Make a connection to the BluetoothSocket
            try {
                // This is a blocking call and will only return on a
                // successful connection or an exception
                mmSocket.connect();
            } catch (IOException e) {
                connectionFailed();
                // Close the socket
                try {
                    mmSocket.close();
                } catch (IOException e2) {
                    Log.e(TAG, "unable to close() socket during connection failure", e2);
                }
                // Start the service over to restart listening mode
                BluetoothChatService.this.start();
                return;
            }

            // Reset the ConnectThread because we're done
            synchronized (BluetoothChatService.this) {
                mConnectThread = null;
            }

            // Start the connected thread
            connected(mmSocket, mmDevice);
        }

        public void cancel() {
            try {
                mmSocket.close();
            } catch (IOException e) {
                Log.e(TAG, "close() of connect socket failed", e);
            }
        }
    }

    /**
     * This thread runs during a connection with a remote device.
     * It handles all incoming and outgoing transmissions.
     */
    private class ConnectedThread extends Thread {
        private final BluetoothSocket mmSocket;
        private final InputStream mmInStream;
        private final OutputStream mmOutStream;

        public ConnectedThread(BluetoothSocket socket) {
            Log.d(TAG, "create ConnectedThread");
            mmSocket = socket;
            InputStream tmpIn = null;
            OutputStream tmpOut = null;

            // Get the BluetoothSocket input and output streams
            try {
                tmpIn = socket.getInputStream();
                tmpOut = socket.getOutputStream();
            } catch (IOException e) {
                Log.e(TAG, "temp sockets not created", e);
            }

            mmInStream = tmpIn;
            mmOutStream = tmpOut;
        }

        public void run() {
            Log.i(TAG, "BEGIN mConnectedThread");
            byte[] buffer = new byte[1024];
            int bytes;

            // Keep listening to the InputStream while connected
            while (true) {
                try {
                    // Read from the InputStream
                    bytes = mmInStream.read(buffer);

                    // Send the obtained bytes to the UI Activity
                    mHandler.obtainMessage(MainActivity.MESSAGE_READ, bytes, -1, buffer)
                            .sendToTarget();
                } catch (IOException e) {
                    Log.e(TAG, "disconnected", e);
                    connectionLost();
                    break;
                }
            }
        }

        /**
         * Write to the connected OutStream.
         * @param buffer  The bytes to write
         */
        public void write(byte[] buffer) {
            try {
                mmOutStream.write(buffer);

                // Share the sent message back to the UI Activity
                mHandler.obtainMessage(MainActivity.MESSAGE_WRITE, -1, -1, buffer)
                        .sendToTarget();
            } catch (IOException e) {
                Log.e(TAG, "Exception during write", e);
            }
        }

        public void cancel() {
            try {
                mmSocket.close();
            } catch (IOException e) {
                Log.e(TAG, "close() of connect socket failed", e);
            }
        }
    }
}
\n
./src/main//java//com//example//rubikrobot//Bluetooth//DeviceListActivity.java
\n
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.rubikrobot.Bluetooth;

import android.app.Activity;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.TextView;

import com.example.rubikrobot.R;

import java.util.Set;


/**
 * This Activity appears as a dialog. It lists any paired devices and devices
 * detected in the area after discovery. When a device is chosen by the user,
 * the MAC address of the device is sent back to the parent Activity in the
 * result Intent.
 */
public class DeviceListActivity extends Activity
{
	// Debugging
	private static final String TAG = "DeviceListActivity";
	private static final boolean D = true;

	// Return Intent extra
	public static String EXTRA_DEVICE_ADDRESS = "device_address";

	// Member fields
	private BluetoothAdapter mBtAdapter;
	private ArrayAdapter<String> mPairedDevicesArrayAdapter;
	private ArrayAdapter<String> mNewDevicesArrayAdapter;

	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);

		// Setup the window
		requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
		setContentView(R.layout.device_list);

		// Set result CANCELED incase the user backs out
		setResult(Activity.RESULT_CANCELED);

		// Initialize the button to perform device discovery
		Button scanButton = (Button) findViewById(R.id.button_scan);
		scanButton.setOnClickListener(new OnClickListener()
		{
			public void onClick(View v)
			{
				doDiscovery();
				v.setVisibility(View.GONE);
			}
		});

		// Initialize array adapters. One for already paired devices and
		// one for newly discovered devices
		mPairedDevicesArrayAdapter = new ArrayAdapter<String>(this,
				R.layout.device_name);
		mNewDevicesArrayAdapter = new ArrayAdapter<String>(this,
				R.layout.device_name);

		// Find and set up the ListView for paired devices
		ListView pairedListView = (ListView) findViewById(R.id.paired_devices);
		pairedListView.setAdapter(mPairedDevicesArrayAdapter);
		pairedListView.setOnItemClickListener(mDeviceClickListener);

		// Find and set up the ListView for newly discovered devices
		ListView newDevicesListView = (ListView) findViewById(R.id.new_devices);
		newDevicesListView.setAdapter(mNewDevicesArrayAdapter);
		newDevicesListView.setOnItemClickListener(mDeviceClickListener);

		// Register for broadcasts when a device is discovered
		IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
		this.registerReceiver(mReceiver, filter);

		// Register for broadcasts when discovery has finished
		filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
		this.registerReceiver(mReceiver, filter);

		// Get the local Bluetooth adapter
		mBtAdapter = BluetoothAdapter.getDefaultAdapter();

		// Get a set of currently paired devices
		Set<BluetoothDevice> pairedDevices = mBtAdapter.getBondedDevices();

		// If there are paired devices, add each one to the ArrayAdapter
		if (pairedDevices.size() > 0)
		{
			findViewById(R.id.title_paired_devices).setVisibility(View.VISIBLE);
			for (BluetoothDevice device : pairedDevices)
			{
				mPairedDevicesArrayAdapter.add(device.getName() + "\n"
						+ device.getAddress());
			}
		}
		else
		{
			String noDevices = getResources().getText(R.string.none_paired)
					.toString();
			mPairedDevicesArrayAdapter.add(noDevices);
		}
	}

	@Override
	protected void onDestroy()
	{
		super.onDestroy();

		// Make sure we're not doing discovery anymore
		if (mBtAdapter != null)
		{
			mBtAdapter.cancelDiscovery();
		}

		// Unregister broadcast listeners
		this.unregisterReceiver(mReceiver);
	}

	/**
	 * Start device discover with the BluetoothAdapter
	 */
	private void doDiscovery()
	{
		if (D) Log.d(TAG, "doDiscovery()");

		// Indicate scanning in the title
		setProgressBarIndeterminateVisibility(true);
		setTitle(R.string.scanning);

		// Turn on sub-title for new devices
		findViewById(R.id.title_new_devices).setVisibility(View.VISIBLE);

		// If we're already discovering, stop it
		if (mBtAdapter.isDiscovering())
		{
			mBtAdapter.cancelDiscovery();
		}

		// Request discover from BluetoothAdapter
		mBtAdapter.startDiscovery();
	}

	// The on-click listener for all devices in the ListViews
	private OnItemClickListener mDeviceClickListener = new OnItemClickListener()
	{
		public void onItemClick(AdapterView<?> av, View v, int arg2, long arg3)
		{
			// Cancel discovery because it's costly and we're about to connect
			mBtAdapter.cancelDiscovery();

			// Get the device MAC address, which is the last 17 chars in the
			// View
			String info = ((TextView) v).getText().toString();
			String address = info.substring(info.length() - 17);

			// Create the result Intent and include the MAC address
			Intent intent = new Intent();
			intent.putExtra(EXTRA_DEVICE_ADDRESS, address);

			// Set result and finish this Activity
			setResult(Activity.RESULT_OK, intent);
			finish();
		}
	};

	// The BroadcastReceiver that listens for discovered devices and
	// changes the title when discovery is finished
	private final BroadcastReceiver mReceiver = new BroadcastReceiver()
	{
		@Override
		public void onReceive(Context context, Intent intent)
		{
			String action = intent.getAction();

			// When discovery finds a device
			if (BluetoothDevice.ACTION_FOUND.equals(action))
			{
				// Get the BluetoothDevice object from the Intent
				BluetoothDevice device = intent
						.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
				// If it's already paired, skip it, because it's been listed
				// already
				if (device.getBondState() != BluetoothDevice.BOND_BONDED)
				{
					mNewDevicesArrayAdapter.add(device.getName() + "\n"
							+ device.getAddress());
				}
				// When discovery is finished, change the Activity title
			}
			else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action))
			{
				setProgressBarIndeterminateVisibility(false);
				setTitle(R.string.select_device);
				if (mNewDevicesArrayAdapter.getCount() == 0)
				{
					String noDevices = getResources().getText(
							R.string.none_found).toString();
					mNewDevicesArrayAdapter.add(noDevices);
				}
			}
		}
	};

}
\n
./src/main//java//com//example//rubikrobot//Camera//ColorRecognition.java
\n
package com.example.rubikrobot.Camera;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Environment;

import com.example.rubikrobot.MainActivity;

import java.io.File;

/**
 * 备注：SD中的存有六张图片，分别命名：1,2,3,4,5,6
 * 图片的命名和方位的关系:1:B,2:F,3:R,4:L,5:D,6:U.
 * 魔方复原算法输入的魔方颜色状态的顺序为：URFDLB,从上到下，从左到右
 */

public class ColorRecognition {
    private Context context;
    private static final String filepath = "/storage/emulated/0/Android/data/com.example.rubikrobot/cache/";//SD卡路径2.
   // private static final String filepath = "/storage/emulated/0/DCIM/Camera/";//SD卡路径
   // File saveDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM); //保存到系统图库中
   // File f=new File(context.getExternalCacheDir(),"asd");
    private static final String filetype = ".jpg";


    /*
     *定义SD卡中图片每一面中9个中心颜色块的像素位置,照片像素：960*720
     *行对应的是颜色块的位置，每一个面有9个颜色块，按照从上到下，从左到右的顺序依次排列，
     *列对应的是x轴的位置和y轴的位置
     */



//    //1号
//    //x轴
//    private static final int color_x_position[]={527,622,728,830,927};
//    //y轴
//
//    private static final int color_y_position[]={187,283,390,486,584};
//
//x轴
private static final int color_x_position[]={1866,2268,2651,3109,3514};
    //y轴
    private static final int color_y_position[]={856,1305,1721,2110,2513};

//4
    //x轴
  //  private static final int color_x_position[]={546,636,737,828,924};
    //y轴
//    private static final int color_y_position[]={204,310,407,508,602};
//    private static final int color_x_position[]={539,645,727,836,933};
//    //y轴
//  //  private static final int color_y_position[]={314,461,595,734,897};
//   // private static final int color_y_position[]={241,355,458,564,690};
//    private static final int color_y_position[]={211,311,405,507,607};

   //2号
//    private static final int color_x_position[]={537,635,746,841,945};
//    //y轴
//    private static final int color_y_position[]={196,297,395,498,601};

//    private static final int color_x_position[]={670,802,920,1046,1167};
//    private static final int color_y_position[]={265,392,502,633,760};
//private static final int color_x_position[]={669,749,864,969,1064};
//    private static final int color_y_position[]={322,418,508,617,708};

    //3号
    //private static final int color_x_position[]={546,638,749,852,952};
    //private static final int color_y_position[]={211,306,407,515,613};


    //9行2列，第一列为x轴，第2列为y轴,行为9个颜色块的编号，按照从左到右，从上到下
    private static int color_block_position[][] = new int[9][2];


    private static Bitmap rawBitmap1;
    private static Bitmap rawBitmap2;
    private static Bitmap rawBitmap3;
    private static Bitmap rawBitmap4;
    private static Bitmap rawBitmap5;
    private static Bitmap rawBitmap6;


    /*
     * 调试用,储存SD卡中六张图片的中心颜色块颜色值,标号对应图片的编号
     * 行对应每张图片9个颜色块，按照从上到下，从做到右的顺序依次排列
     * 列分别对应的R、G、B的值
     */
    private static int photo1_rgb[][] = new int[9][3];
    private static int photo2_rgb[][] = new int[9][3];
    private static int photo3_rgb[][] = new int[9][3];
    private static int photo4_rgb[][] = new int[9][3];
    private static int photo5_rgb[][] = new int[9][3];
    private static int photo6_rgb[][] = new int[9][3];


    //储存颜色结果，颜色标识符为数字：1,2,3,4,5,6
    public static int photo_note[] = new int[54];
    //储存颜色结果，颜色标识符为:L,R,F,B,U,D
    public static String color_mask = new String();

    /*
     *由于进行颜色识别魔方的状态发生了改变，所以每一面对应的颜色块也要发生改变
     */
    public String AdjustColor_FirstPhoto(String surface_color) {
        String surface_variedcolor = "";
        surface_variedcolor += surface_color.charAt(6);
        surface_variedcolor += surface_color.charAt(3);
        surface_variedcolor += surface_color.charAt(0);
        surface_variedcolor += surface_color.charAt(7);
        surface_variedcolor += surface_color.charAt(4);
        surface_variedcolor += surface_color.charAt(1);
        surface_variedcolor += surface_color.charAt(8);
        surface_variedcolor += surface_color.charAt(5);
        surface_variedcolor += surface_color.charAt(2);
        return surface_variedcolor;
    }


    public String AdjustColor_SecondPhoto(String surface_color) {

        String surface_variedcolor = "";
        surface_variedcolor += surface_color.charAt(2);
        surface_variedcolor += surface_color.charAt(5);
        surface_variedcolor += surface_color.charAt(8);
        surface_variedcolor += surface_color.charAt(1);
        surface_variedcolor += surface_color.charAt(4);
        surface_variedcolor += surface_color.charAt(7);
        surface_variedcolor += surface_color.charAt(0);
        surface_variedcolor += surface_color.charAt(3);
        surface_variedcolor += surface_color.charAt(6);
        return surface_variedcolor;
    }

    public String AdjustColor_ThirdPhoto(String surface_color) {

        String surface_variedcolor = "";
        surface_variedcolor += surface_color.charAt(2);
        surface_variedcolor += surface_color.charAt(5);
        surface_variedcolor += surface_color.charAt(8);
        surface_variedcolor += surface_color.charAt(1);
        surface_variedcolor += surface_color.charAt(4);
        surface_variedcolor += surface_color.charAt(7);
        surface_variedcolor += surface_color.charAt(0);
        surface_variedcolor += surface_color.charAt(3);
        surface_variedcolor += surface_color.charAt(6);
        return surface_variedcolor;
    }

    public String AdjustColor_FourthPhoto(String surface_color) {
        String surface_variedcolor = "";
        surface_variedcolor += surface_color.charAt(2);
        surface_variedcolor += surface_color.charAt(5);
        surface_variedcolor += surface_color.charAt(8);
        surface_variedcolor += surface_color.charAt(1);
        surface_variedcolor += surface_color.charAt(4);
        surface_variedcolor += surface_color.charAt(7);
        surface_variedcolor += surface_color.charAt(0);
        surface_variedcolor += surface_color.charAt(3);
        surface_variedcolor += surface_color.charAt(6);
        return surface_variedcolor;

    }

    public String AdjustColor_FifthPhoto(String surface_color) {

        String surface_variedcolor = "";
        surface_variedcolor += surface_color.charAt(8);
        surface_variedcolor += surface_color.charAt(7);
        surface_variedcolor += surface_color.charAt(6);
        surface_variedcolor += surface_color.charAt(5);
        surface_variedcolor += surface_color.charAt(4);
        surface_variedcolor += surface_color.charAt(3);
        surface_variedcolor += surface_color.charAt(2);
        surface_variedcolor += surface_color.charAt(1);
        surface_variedcolor += surface_color.charAt(0);
        return surface_variedcolor;

    }


    /*
     *得到RGB颜色值所对应的颜色标识
     *
     *
     */
    public static String ColorRecog(int photo_color[]) {
        int color_diff[] = new int[6];
        int key;
        String color = "";

        int R = photo_color[0];
        int G = photo_color[1];
        int B = photo_color[2];
        //和第一张图片中心颜色块差值
        color_diff[0] = (Math.abs(R - photo1_rgb[4][0]) + Math.abs(G - photo1_rgb[4][1]) + Math.abs(B - photo1_rgb[4][2]));
        //和第二张图片中心颜色块差值
        color_diff[1] = (Math.abs(R - photo2_rgb[4][0]) + Math.abs(G - photo2_rgb[4][1]) + Math.abs(B - photo2_rgb[4][2]));
        //和第三张图片中心颜色块差值
        color_diff[2] = (Math.abs(R - photo3_rgb[4][0]) + Math.abs(G - photo3_rgb[4][1]) + Math.abs(B - photo3_rgb[4][2]));
        //和第四张图片中心颜色块差值
        color_diff[3] = (Math.abs(R - photo4_rgb[4][0]) + Math.abs(G - photo4_rgb[4][1]) + Math.abs(B - photo4_rgb[4][2]));
        //和第五张图片中心颜色块差值
        color_diff[4] = (Math.abs(R - photo5_rgb[4][0]) + Math.abs(G - photo5_rgb[4][1]) + Math.abs(B - photo5_rgb[4][2]));
        //和第六张图片中心颜色块差值
        color_diff[5] = (Math.abs(R - photo6_rgb[4][0]) + Math.abs(G - photo6_rgb[4][1]) + Math.abs(B - photo6_rgb[4][2]));
        key = Get_MinKey(color_diff);


        switch (key) {
            case 0: {
                color = "L";
            }
            break;
            case 1: {
                color = "R";
            }
            break;
            case 2: {
                color = "F";
            }
            break;
            case 3: {
                color = "B";
            }
            break;
            case 4: {
                color = "U";
            }
            break;
            case 5: {
                color = "D";
            }
            break;

        }

        return (color);
    }

    /*
     *获取一个数组中最小值所在的数组标号
     */
    public static int Get_MinKey(int color_diff[]) {
        int min = color_diff[0];
        int min_key = 0;
        for (int i = 1; i < color_diff.length; i++) {
            if (min > color_diff[i]) {
                min = color_diff[i];
                min_key = i;
            }
        }
        return min_key;

    }

    /*
     *获取六张图片的信息
     */
    public static void GetPhoto_fromSD() {

        //颜色块像素排列位置
        color_block_position[0][0]=color_x_position[0];
        color_block_position[0][1]=color_y_position[2];
        color_block_position[1][0]=color_x_position[1];
        color_block_position[1][1]=color_y_position[1];
        color_block_position[2][0]=color_x_position[2];
        color_block_position[2][1]=color_y_position[0];
        color_block_position[3][0]=color_x_position[1];
        color_block_position[3][1]=color_y_position[3];
        color_block_position[4][0]=color_x_position[2];
        color_block_position[4][1]=color_y_position[2];
        color_block_position[5][0]=color_x_position[3];
        color_block_position[5][1]=color_y_position[1];
        color_block_position[6][0]=color_x_position[2];
        color_block_position[6][1]=color_y_position[4];
        color_block_position[7][0]=color_x_position[3];
        color_block_position[7][1]=color_y_position[3];
        color_block_position[8][0]=color_x_position[4];
        color_block_position[8][1]=color_y_position[2];

        rawBitmap1 = BitmapFactory.decodeFile(filepath + String.valueOf(1) + filetype);
        rawBitmap2 = BitmapFactory.decodeFile(filepath + String.valueOf(2) + filetype);
        rawBitmap3 = BitmapFactory.decodeFile(filepath + String.valueOf(3) + filetype);
        rawBitmap4 = BitmapFactory.decodeFile(filepath + String.valueOf(4) + filetype);
        rawBitmap5 = BitmapFactory.decodeFile(filepath + String.valueOf(5) + filetype);
        rawBitmap6 = BitmapFactory.decodeFile(filepath + String.valueOf(6) + filetype);
        System.out.println(rawBitmap6+"这是图片1");
    }


    /*
     *由像素点数据得到R,G,B值
     */
    public static int[] Get_RGB(int photo_color) {
        int RGB_color[] = new int[3];
        RGB_color[0] = ((photo_color & 0xff0000) >> 16);
        RGB_color[1] = ((photo_color & 0xff00) >> 8);
        RGB_color[2] = ((photo_color & 0xff));
      //  System.out.println(RGB_color[0]+""+RGB_color[1]+RGB_color[2]);
        return RGB_color;
    }


    /*
     *输出魔方六个面的所有的颜色状态，可以直接作为魔方解算算法的输入
     *备注：魔方解算算法的魔方状态次序：U R F D L B(6,3,2,5,4,1)
     *颜色识别完之后，魔方的状态发生了变化：
     *拍摄照片的名称和魔方次序的对应关系:1:B 2:F 3:R 4:L 5:D 6:U.
     */
    public void Get_ColorMask(int pixel_x_bias, int pixel_y_bias) {
        int block_nums;
        color_mask="";//一定一定要初始化，否则后果很严重！！！！！
        String mask_color1="";
        String mask_color2="";
        String mask_color3="";
        String mask_color4="";
        String mask_color5="";
        String mask_color6="";


        Get_AllPhoto_GRB(pixel_x_bias, pixel_y_bias);

        //U(6)
        for (block_nums = 0; block_nums < 9; block_nums++)
            mask_color1 += ColorRecog(photo6_rgb[block_nums]);
        color_mask+=mask_color1;

       //R(3)
        for (block_nums = 0; block_nums < 9; block_nums++)
            mask_color2 += ColorRecog(photo3_rgb[block_nums]);
        color_mask+=AdjustColor_ThirdPhoto(mask_color2);

        //F(2)
        for (block_nums = 0; block_nums < 9; block_nums++)
            mask_color3 += ColorRecog(photo2_rgb[block_nums]);
        color_mask+=AdjustColor_SecondPhoto(mask_color3);

        //D(5)
        for (block_nums = 0; block_nums < 9; block_nums++)
            mask_color4 += ColorRecog(photo5_rgb[block_nums]);
        color_mask+=AdjustColor_FifthPhoto(mask_color4);

        //L(4)
        for (block_nums = 0; block_nums < 9; block_nums++)
            mask_color5 += ColorRecog(photo4_rgb[block_nums]);
        color_mask+=AdjustColor_FourthPhoto(mask_color5);

        //B(1)
        for (block_nums = 0; block_nums < 9; block_nums++)
            mask_color6 += ColorRecog(photo1_rgb[block_nums]);
        color_mask+=AdjustColor_FirstPhoto(mask_color6);

    }


    /*
     *判断是否发生了颜色识别的第一类错误：54个面颜色块标识并不是每9类一组
     *输入：魔方的54个颜色块的颜色标识
     */

    public static boolean Analy_Error1() {
        int i;
        int num1 = 0;
        int num2 = 0;
        int num3 = 0;
        int num4 = 0;
        int num5 = 0;
        int num6 = 0;

        for (i = 0; i < 54; i++) {
            switch (color_mask.charAt(i)) {
                case 'L': {
                    num1++;
                }
                break;

                case 'R': {
                    num2++;
                }
                break;

                case 'F': {
                    num3++;
                }
                break;

                case 'B': {
                    num4++;
                }
                break;

                case 'U': {
                    num5++;
                }
                break;
                case 'D': {
                    num6++;
                }
                break;

                default: {

                }
                break;
            }
        }

        if (num1 == 9 && num2 == 9 && num3 == 9 && num4 == 9 && num5 == 9 && num6 == 9)
            return true;
        else
            return false;

    }


    /*
     *魔方解算算法调用
     */
    public void Get_RubikTotalColor(int x_bias, int y_bias) {
        GetPhoto_fromSD();           //读取SD中的6张图片信息
        Get_ColorMask(x_bias, y_bias); //获取54块颜色块的颜色
    }


    //调试用
    public String look_color() {

        String color = new String("");
        color += "\r\n";


        for (int i = 0; i < 54; i++) {
            color += color_mask.charAt(i);
            color += " ";

            if ((i + 1) % 9 == 0)
                color += "\r\n";
        }

        return color;

    }


    //调试用

    //得到所有的RGB值
    public static void Get_AllPhoto_GRB(int pixel_x_bias, int pixel_y_bias) {


        //第一张图片
        int block_num;
        for (block_num = 0; block_num < 9; block_num++)
            photo1_rgb[block_num] = Get_RGB(rawBitmap1.getPixel(color_block_position[block_num][0] + pixel_x_bias, color_block_position[block_num][1] + pixel_y_bias));

        for (block_num = 0; block_num < 9; block_num++)
            photo2_rgb[block_num] = Get_RGB(rawBitmap2.getPixel(color_block_position[block_num][0] + pixel_x_bias, color_block_position[block_num][1] + pixel_y_bias));

        for (block_num = 0; block_num < 9; block_num++)
            photo3_rgb[block_num] = Get_RGB(rawBitmap3.getPixel(color_block_position[block_num][0] + pixel_x_bias, color_block_position[block_num][1] + pixel_y_bias));

        for (block_num = 0; block_num < 9; block_num++)
            photo4_rgb[block_num] = Get_RGB(rawBitmap4.getPixel(color_block_position[block_num][0] + pixel_x_bias, color_block_position[block_num][1] + pixel_y_bias));

        for (block_num = 0; block_num < 9; block_num++)
            photo5_rgb[block_num] = Get_RGB(rawBitmap5.getPixel(color_block_position[block_num][0] + pixel_x_bias, color_block_position[block_num][1] + pixel_y_bias));

        for (block_num = 0; block_num < 9; block_num++)
            photo6_rgb[block_num] = Get_RGB(rawBitmap6.getPixel(color_block_position[block_num][0] + pixel_x_bias, color_block_position[block_num][1] + pixel_y_bias));
    }


    //得到所有的颜色标识
    public static void Get_color_note(int pixel_x_bias, int pixel_y_bias) {

        int block_nums;
        Get_AllPhoto_GRB(pixel_x_bias, pixel_y_bias);

        for (block_nums = 0; block_nums < 9; block_nums++)
            photo_note[block_nums] = RGB_to_ColorNote(photo1_rgb[block_nums]);

        for (block_nums = 0; block_nums < 9; block_nums++)
            photo_note[9 + block_nums] = RGB_to_ColorNote(photo2_rgb[block_nums]);

        for (block_nums = 0; block_nums < 9; block_nums++)
            photo_note[9 * 2 + block_nums] = RGB_to_ColorNote(photo3_rgb[block_nums]);

        for (block_nums = 0; block_nums < 9; block_nums++)
            photo_note[9 * 3 + block_nums] = RGB_to_ColorNote(photo4_rgb[block_nums]);

        for (block_nums = 0; block_nums < 9; block_nums++)
            photo_note[9 * 4 + block_nums] = RGB_to_ColorNote(photo5_rgb[block_nums]);

        for (block_nums = 0; block_nums < 9; block_nums++)
            photo_note[9 * 5 + block_nums] = RGB_to_ColorNote(photo6_rgb[block_nums]);


    }


    //得到RGB颜色值对应的颜色标识
    public static int RGB_to_ColorNote(int photo_color[]) {
        int color_diff[] = new int[6];
        int key;

        int R = photo_color[0];
        int G = photo_color[1];
        int B = photo_color[2];

        //和第一张图片中心颜色块差值
        color_diff[0] = (Math.abs(R - photo1_rgb[4][0]) + Math.abs(G - photo1_rgb[4][1]) + Math.abs(B - photo1_rgb[4][2]));
        //和第二张图片中心颜色块差值
        color_diff[1] = (Math.abs(R - photo2_rgb[4][0]) + Math.abs(G - photo2_rgb[4][1]) + Math.abs(B - photo2_rgb[4][2]));
        //和第三张图片中心颜色块差值
        color_diff[2] = (Math.abs(R - photo3_rgb[4][0]) + Math.abs(G - photo3_rgb[4][1]) + Math.abs(B - photo3_rgb[4][2]));
        //和第四张图片中心颜色块差值
        color_diff[3] = (Math.abs(R - photo4_rgb[4][0]) + Math.abs(G - photo4_rgb[4][1]) + Math.abs(B - photo4_rgb[4][2]));
        //和第五张图片中心颜色块差值
        color_diff[4] = (Math.abs(R - photo5_rgb[4][0]) + Math.abs(G - photo5_rgb[4][1]) + Math.abs(B - photo5_rgb[4][2]));
        //和第六张图片中心颜色块差值
        color_diff[5] = (Math.abs(R - photo6_rgb[4][0]) + Math.abs(G - photo6_rgb[4][1]) + Math.abs(B - photo6_rgb[4][2]));
        key = Get_MinKey(color_diff);

        return (key + 1);
    }

    //调试用
    public String look_colo() {

        String color = new String("");
        color += "\r\n";

        for (int i = 0; i < 54; i++) {
            color += String.valueOf(photo_note[i]);
            color += " ";

            if ((i + 1) % 9 == 0)
                color += "\r\n";
        }

        return color;

    }


    public static boolean Anal_Error1() {
        int i;
        int num1 = 0;
        int num2 = 0;
        int num3 = 0;
        int num4 = 0;
        int num5 = 0;
        int num6 = 0;

        for (i = 0; i < 54; i++) {
            switch (photo_note[i]) {
                case 1: {
                    num1++;
                }
                break;

                case 2: {
                    num2++;
                }
                break;

                case 3: {
                    num3++;
                }
                break;

                case 4: {
                    num4++;
                }
                break;

                case 5: {
                    num5++;
                }
                break;
                case 6: {
                    num6++;
                }
                break;

                default: {

                }
                break;


            }

        }


        if (num1 == 9 && num2 == 9 && num3 == 9 && num4 == 9 && num5 == 9 && num6 == 9)
            return true;
        else
            return false;

    }



}
\n
./src/main//java//com//example//rubikrobot//Camera//KNN.java
\n
package com.example.rubikrobot.Camera;

/**
 * Created by Administrator on 2016/6/12.
 */
public class KNN {

}
\n
./src/main//java//com//example//rubikrobot//InstructionOptimization//TrinaryTree.java
\n
package com.example.rubikrobot.InstructionOptimization;

public class TrinaryTree {
	
	
	String getMinSubTrinaryTree(String str_SubInput,int []len_branch)
	{
		if (str_SubInput.length()<=2)
		{
			len_branch[0] = 0;
			return "";
		}
		if (str_SubInput.charAt(0)=='U' || str_SubInput.charAt(0)=='D')
		{
			//int NNlen=0,LLlen=0,FFlen=0;
			int NNlen[]=new int [1];
			NNlen[0]=0;
			
			int LLlen[]=new int [1];
			LLlen[0]=0;

			int FFlen[]=new int [1];
			FFlen[0]=0;
			
			String NNstr,LLstr,FFstr;
			String tmpNNstr,tmpLLstr,tmpFFstr;
			//string subEquation = str_SubInput.substr(2);

			tmpNNstr = Turn_Equachange(str_SubInput,"NN",0);
			tmpLLstr = Turn_Equachange(str_SubInput,"LL",0);
			tmpFFstr = Turn_Equachange(str_SubInput,"FF",0);
			
			NNstr = getMinSubTrinaryTree(tmpNNstr.substring(2),NNlen);
			LLstr = getMinSubTrinaryTree(tmpLLstr.substring(2),LLlen);
			FFstr = getMinSubTrinaryTree(tmpFFstr.substring(2),FFlen);

			NNlen[0]+=16;
			LLlen[0]+=10;
			FFlen[0]+=10;

			if(NNlen[0]<=LLlen[0] && NNlen[0]<=FFlen[0])
			{
				len_branch[0] = NNlen[0];
				NNstr = "LL"+tmpLLstr.substring(0,2)+"RR"+NNstr;
				return NNstr;
			}
			else if(LLlen[0]<=NNlen[0] &&LLlen[0]<=FFlen[0])
			{
				len_branch[0] = LLlen[0];
				LLstr = "LL"+tmpLLstr.substring(0,2)+LLstr;
				return LLstr;
			}
			else
			{
				len_branch[0] = FFlen[0];
				FFstr = "FF"+tmpFFstr.substring(0,2)+FFstr;
				return FFstr;
			}
		}
		else
		{
			int step_num=0;
			if (Connect_Action(str_SubInput.charAt(0),str_SubInput.charAt(2)))
			{
				String nowStr = getMinSubTrinaryTree(str_SubInput.substring(4),len_branch);
				if(str_SubInput.charAt(1)=='2'||str_SubInput.charAt(3)=='2')
				{
					step_num=8;		
				}
				else
				{
					step_num=4;			
				}
				
				len_branch[0]= len_branch[0]+step_num;
				//len_branch[0]= len_branch[0]+4;
				nowStr = str_SubInput.substring(0,4)+nowStr;
				return nowStr;
			}
			String nowStr = getMinSubTrinaryTree(str_SubInput.substring(2),len_branch);
			if(str_SubInput.charAt(1)=='2')
			{
				step_num=8;			
			}
			else
			{
				step_num=4;			
			}
			len_branch[0] = len_branch[0]+step_num;
			//len_branch[0] = len_branch[0]+4;
			nowStr = str_SubInput.substring(0,2)+nowStr;
			return nowStr;
		}

	}

	
	String getMinTrinaryTree(String str_input) 
	{
		int len_branch[]=new int [1];
		len_branch[0]=0;
		str_input=Add_ClockwiseMark(str_input)+"!!";
		return getMinSubTrinaryTree(str_input,len_branch);
	}
	
	String getMinSubBinaryTree(String str_SubInput,int []len_branch)
	{
		if (str_SubInput.length()<=2)
		{
			len_branch[0] = 0;
			return "";
		}
		if (str_SubInput.charAt(0)=='U' || str_SubInput.charAt(0)=='D')
		{
			//int NNlen=0,LLlen=0,FFlen=0;
			
			int LLlen[]=new int [1];
			LLlen[0]=0;

			int FFlen[]=new int [1];
			FFlen[0]=0;
			
			String NNstr,LLstr,FFstr;
			String tmpNNstr,tmpLLstr,tmpFFstr;
			//string subEquation = str_SubInput.substr(2);

			//tmpNNstr = Turn_Equachange(str_SubInput,"NN",0);
			tmpLLstr = Turn_Equachange(str_SubInput,"LL",0);
			tmpFFstr = Turn_Equachange(str_SubInput,"FF",0);
			//NNstr = getMinSubTree(tmpNNstr.substr(2),NNlen);
			LLstr = getMinSubBinaryTree(tmpLLstr.substring(2),LLlen);
			FFstr = getMinSubBinaryTree(tmpFFstr.substring(2),FFlen);

			//NNlen+=16;
			LLlen[0]+=10;
			FFlen[0]+=10;

			/*if(NNlen<=LLlen && NNlen<=FFlen)
			{
				len_branch = NNlen;
				NNstr = "LL"+tmpLLstr.substr(0,2)+"RR"+NNstr;
				return NNstr;
			}
			else */if (/*LLlen<=NNlen &&*/ LLlen[0]<=FFlen[0])
			{
				len_branch[0] = LLlen[0];
				LLstr = "LL"+tmpLLstr.substring(0,2)+LLstr;
				return LLstr;
			}
			else
			{
				len_branch[0] = FFlen[0];
				FFstr = "FF"+tmpFFstr.substring(0,2)+FFstr;
				return FFstr;
			}
		}
		else
		{
			int step_num=0;
			if (Connect_Action(str_SubInput.charAt(0),str_SubInput.charAt(2)))
			{
				String nowStr = getMinSubBinaryTree(str_SubInput.substring(4),len_branch);
				if(str_SubInput.charAt(1)=='2'||str_SubInput.charAt(3)=='2')
				{
					step_num=8;		
				}
				else
				{
					step_num=4;			
				}
				
				len_branch[0]= len_branch[0]+step_num;
				//len_branch[0]= len_branch[0]+4;
				nowStr = str_SubInput.substring(0,4)+nowStr;
				return nowStr;
			}
			String nowStr = getMinSubBinaryTree(str_SubInput.substring(2),len_branch);
			if(str_SubInput.charAt(1)=='2')
			{
				step_num=8;			
			}
			else
			{
				step_num=4;			
			}
			len_branch[0] = len_branch[0]+step_num;
			//len_branch[0] = len_branch[0]+4;
			nowStr = str_SubInput.substring(0,2)+nowStr;
			return nowStr;
		}

	}

	String getMinBinaryTree(String str_input) 
	{
		int len_branch[]=new int [1];
		
		str_input=Add_ClockwiseMark(str_input)+"!!";
		return getMinSubBinaryTree(str_input,len_branch);
	}

	
	/*
	 * 计算优化后的指令的舵机执行步数
	 */
	public int getStepNum_Equation(String  optim_equation)
	{
		int step_num=0;

		optim_equation=optim_equation+"!!!";
		for(int i=0;i<optim_equation.length()-3;)
		{
			if((Connect_Action(optim_equation.charAt(i),optim_equation.charAt(i+2)))&&((optim_equation.charAt(i)!=optim_equation.charAt(i+1))&&(optim_equation.charAt(i+2)!=optim_equation.charAt(i+3))))//可以连续执行的两个动作组
			{
				
				if(optim_equation.charAt(i+1)=='2'||optim_equation.charAt(i+3)=='2')
				{
					step_num+=8;
				}
				else
				{
					step_num+=4;	
				}
				
				i+=4;
			}
			else//不能连续执行
			{
				
				if(optim_equation.charAt(i)==optim_equation.charAt(i+1))
				{
					step_num+=6;
				}
				else if(optim_equation.charAt(i+1)=='2')
				{
					step_num+=8;
				}
				else
				{
					step_num+=4;	
				}
				
				i+=2;
				
			}
			
		}
				
		return step_num;
		
	}
	
	
	/*
	 *对魔方解算算法生成的字符串，在原来顺时针单指令的后面加上一个字符'^'，便于下位机解析
	 *
	 */
	public String Add_ClockwiseMark(String equation)
	{
		equation=equation+"!";
		for(int i = 0;i<equation.length()-1;)
		{
			if((equation.charAt(i)<=0X5a&&equation.charAt(i)>=0X41)&&((equation.charAt(i+1)<=0X5a&&equation.charAt(i+1)>=0X41)||(equation.charAt(i+1)=='!')))
			{
				StringBuffer euqa_change=new StringBuffer(equation);
				euqa_change.insert(i+1, '^');
				equation=euqa_change.toString();
				i+=2;
			}
			else
			{
				i++;
			}
			
		}
		StringBuffer equation_add=new StringBuffer(equation);
		equation_add.deleteCharAt(equation_add.length()-1);
		equation=equation_add.toString();
		
		return equation;
	}
	
	
	/*魔方的位置在发生翻转时，得到变化之后的复原指令，有前后左右四种位置变化
	 *start_line是开始改变的字符串标号（包括start_line）
	 *change_sig有四种取值：L,R,F,B
	 */
	public  String Turn_Equachange(String equation,String change_sig,int start_line)
	{
		char L_sig,R_sig,F_sig,B_sig,U_sig,D_sig;
		String equation1=equation.substring(0,start_line); //不包括start_line
		String equation2=equation.substring(start_line);   //包括start_line
		StringBuffer equation3=new StringBuffer(equation2);
		char change_sign=change_sig.charAt(0);
		switch(change_sign)
		{
			case 'L':
			{
				L_sig='D';
				R_sig='U';
				F_sig='F';
				B_sig='B';
				U_sig='L';
				D_sig='R';

			}break;
			
			case 'R':
			{
				L_sig='U';
				R_sig='D';
				F_sig='F';
				B_sig='B';
				U_sig='R';
				D_sig='L';
				
			}break;
			
			
			case 'F':
			{
				L_sig='L';
				R_sig='R';
				F_sig='D';
				B_sig='U';
				U_sig='F';
				D_sig='B';
				
			}break;
			
			case 'B':
			{
				L_sig='L';
				R_sig='R';
				F_sig='U';
				B_sig='D';
				U_sig='B';
				D_sig='F';
				
			}break;
			default:
			{
				L_sig='L';
				R_sig='R';
				F_sig='F';
				B_sig='B';
				U_sig='U';
				D_sig='D';	
				
			}break;
			
		}
		
		for(int i=0;i<equation3.length();i++)
		{
				switch(equation3.charAt(i))
				{
					case 'L':
					{
						equation3.setCharAt(i,L_sig);
					}break;
					
					case 'R':
					{
						equation3.setCharAt(i,R_sig);						
					}break;
					
					case 'F':
					{
						equation3.setCharAt(i,F_sig);
					}break;
					
					case 'B':
					{
						equation3.setCharAt(i,B_sig);
					}break;
					
					case 'U':
					{
						equation3.setCharAt(i,U_sig);
					}break;
					
					case 'D':
					{
						equation3.setCharAt(i,D_sig);
					}break;
					
					default:
					{
						
					}break;
						
				}
		}

		return (equation1+equation3.toString());
	}
	

	
	public  boolean  Connect_Action( char char1,char char2)
	{	
		if((char1=='L'&&char2=='R')||(char1=='R'&&char2=='L')||(char1=='F'&&char2=='B')||(char1=='B'&&char2=='F'))
		{
			return true;
		}	
		
		else 
		{
			return false;	
		}		
	}
	
	/*
	 *为优化的魔方复原指令加上开始和结束标志位
	 */
	public String Pack_Optim_Equation(String equation )
	{
		StringBuffer pack=new StringBuffer(getMinBinaryTree(equation));
		pack.insert(0,'#');
		pack.insert(pack.length(),'!');
		return(pack.toString());
	}
	
	/*
	 * 把魔方解算算法解出来的复原公式转化为下位机能够识别的指令，但不做优化
	 * 备注：方便比较优化效果
	 * 
	 */
	public String No_Optim_Equation(String equation)
	{
		String change_equation="";
		equation=Add_ClockwiseMark(equation);
		for(int i=0;i<equation.length();)
		{
			if(equation.charAt(i)=='L'||equation.charAt(i)=='R'||equation.charAt(i)=='F'||equation.charAt(i)=='B')
			{
				change_equation=equation.substring(i,i+2)+change_equation;	
			}
			else
			{
				change_equation="LL"+Turn_Equachange(equation.substring(i,i+2),"LL",0)+"RR"+change_equation;
			}
			
			i+=2;
		}
		
		return change_equation; 
		
	}
	


	/*
	 * 计算未优化前的指令对应的舵机执行步数
	 */
	int getStepNum_Nooptim(String  nooptim_equation)
	{
		int step_num=0;
		nooptim_equation=No_Optim_Equation(nooptim_equation);
		nooptim_equation+="!";
		for(int i=0;i<nooptim_equation.length()-1;)
		{
			if(nooptim_equation.charAt(i)==nooptim_equation.charAt(i+1))
			{
				step_num+=6;
			}
			else if(nooptim_equation.charAt(i+1)=='2')
			{
				step_num+=8;	
			}
			else
			{
				step_num+=4;		
			}
			
			i+=2;
		}
				
		return step_num;
		
	}
}


\n
./src/main//java//com//example//rubikrobot//MainActivity.java
\n
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.rubikrobot;

import android.Manifest;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.PixelFormat;

import android.hardware.Camera;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.provider.MediaStore;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.view.inputmethod.EditorInfo;
import android.widget.Button;
import android.widget.PopupMenu;
import android.widget.TextView;
import android.widget.Toast;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.List;

import android.view.MotionEvent;

import androidx.annotation.NonNull;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import com.example.rubikrobot.Bluetooth.BluetoothChatService;
import com.example.rubikrobot.Bluetooth.DeviceListActivity;
import com.example.rubikrobot.Camera.ColorRecognition;
import com.example.rubikrobot.Solution.RubikRobot;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;


/**
 * This is the main Activity that displays the current chat session.
 */
@SuppressLint("NewApi") public class MainActivity extends Activity {
    // Debugging
    private static final String TAG = "MainActivity";
    private static final boolean D = true;

    // Message types sent from the BluetoothChatService Handler
    public static final int MESSAGE_STATE_CHANGE = 1;
    public static final int MESSAGE_READ = 2;
    public static final int MESSAGE_WRITE = 3;
    public static final int MESSAGE_DEVICE_NAME = 4;
    public static final int MESSAGE_TOAST = 5;

    // Key names received from the BluetoothChatService Handler
    public static final String DEVICE_NAME = "device_name";
    public static final String TOAST = "toast";

    // Intent request codes
    private static final int REQUEST_CONNECT_DEVICE = 1;
    private static final int REQUEST_ENABLE_BT = 2;

    //与屏幕和画笔有关的参数
    private int screenWidth;//屏幕宽度
    private int screenHeight;//屏幕高度
    private int locate_x;
    private int locate_y;
    private int lineWidth_x = 70;//中心十字x轴的长度
    private int lineWidth_y = 58;//中心十字x轴的长度
    WindowManager wm;

    private SurfaceView cameraSurface;
    private SurfaceView locateSurface;
    private Button link_bluetooth;
    // Layout Views
    private TextView mTitle;

    // Name of the connected device
    private String mConnectedDeviceName = null;
    // String buffer for outgoing messages
    private StringBuffer mOutStringBuffer;
    // Local Bluetooth adapter
    private BluetoothAdapter mBluetoothAdapter = null;
    // Member object for the chat services
    private BluetoothChatService mChatService = null;

    // Receive blubooth data
    String readMessage;
    byte[] readchars = new byte[10];

    // Take Photos
    private Camera camera;
    private Camera.Parameters parameters = null;
    Bundle bundle = null;

    private static int photo_order = 0;


    //ColorRecognition
   // ColorRecognition colorRecognition = new ColorRecognition();
    ColorRecognition colorRecognition = new ColorRecognition();
    //RubikSolution

    private double time1;
    private double time2;

    RubikRobot rubikrobot = new RubikRobot();
    SurfaceHolder holder;

    //测试相机拍照的时间,测试得到的拍照时间小的在100ms，大的在1500ms左右，建议2000ms
    private int time10;//开始时间
    private int time11;//结束时间

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
       // if (D) Log.e(TAG, "+++ ON CREATE +++");
        // Set up the window layout
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.main);
        getWindow().setFeatureInt(Window.FEATURE_NO_TITLE, R.layout.custom_title);

        // Set up the custom title
        mTitle = findViewById(R.id.title_left_text);
        mTitle.setText(R.string.app_name);
        mTitle =findViewById(R.id.title_right_text);
     //   wm = (WindowManager) this.getSystemService(Context.WINDOW_SERVICE);
      //  wm = (WindowManager) this.getSystemService(Context.WINDOW_SERVICE);
      //  screenWidth = wm.getDefaultDisplay().getWidth();
      //  screenHeight = wm.getDefaultDisplay().getHeight();
        // surfaceView.getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);

        cameraSurface = findViewById(R.id.surfaceView1);
        // cameraSurface.getHolder().setFixedSize(1280, 720);
        cameraSurface.getHolder().setFixedSize(1024, 768);
        cameraSurface.getHolder().setKeepScreenOn(true);
        cameraSurface.getHolder().setFormat(PixelFormat.TRANSPARENT);
        cameraSurface.getHolder().addCallback(new SurfaceCallback());
        cameraSurface.setSecure(true);

        locateSurface = findViewById(R.id.surfaceView2);
       // locateSurface.getHolder().setFixedSize(1024, 768);
        locateSurface.getHolder().addCallback(new SurfaceCallback());
        locateSurface.getHolder().setFormat(PixelFormat.TRANSLUCENT);
        locateSurface.setZOrderMediaOverlay(true);

        // 获取屏幕分辨率尺寸
        wm = (WindowManager) this.getSystemService(Context.WINDOW_SERVICE);
        DisplayMetrics display = getResources().getDisplayMetrics();
        screenWidth = display.widthPixels;
        screenHeight = display.heightPixels;
        System.out.println("宽"+screenWidth+"高"+screenHeight);
        //Toast.makeText(MainActivity.this,String.valueOf(screenWidth)+" "+String.valueOf(screenHeight),Toast.LENGTH_LONG).show();
        //计算预览界面和硬件平台的标定位置中心，这里屏幕中心
        locate_x = screenWidth / 2;
        locate_y = screenHeight / 2;


        // Get local Bluetooth adapter
        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();

        // If the adapter is null, then Bluetooth is not supported
        if (mBluetoothAdapter == null) {
            Toast.makeText(this, "蓝牙不可用", Toast.LENGTH_LONG).show();
            finish();
            return;
        }
        link_bluetooth=findViewById(R.id.link_bluetooth);
        link_bluetooth.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                showPopupMenu(view);
            }
        });

    }
    private void showPopupMenu(View view) {
        // View当前PopupMenu显示的相对View的位置
        PopupMenu popupMenu = new PopupMenu(this, view);
        // menu布局
        popupMenu.getMenuInflater().inflate(R.menu.option_menu, popupMenu.getMenu());
        // menu的item点击事件
        popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
            @Override
            public boolean onMenuItemClick(MenuItem item) {
                switch (item.getItemId()) {
                    case R.id.scan:
                        // Launch the DeviceListActivity to see devices and do scan
                        Intent serverIntent = new Intent();
                        serverIntent.setClass(MainActivity.this, DeviceListActivity.class);
                        startActivityForResult(serverIntent, REQUEST_CONNECT_DEVICE);
                        return true;
                    case R.id.discoverable:
                        // Ensure this device is discoverable by others
                        ensureDiscoverable();
                        return true;
                }
                return false;
            }
        });
        // PopupMenu关闭事件
        popupMenu.setOnDismissListener(new PopupMenu.OnDismissListener() {
            @Override
            public void onDismiss(PopupMenu menu) {
                //Toast.makeText(getApplicationContext(), "关闭PopupMenu", Toast.LENGTH_SHORT).show();
            }
        });
        popupMenu.show();
    }

    @Override
    public void onStart() {
        super.onStart();
        if (D) Log.e(TAG, "++ ON START ++");

        // If BT is not on, request that it be enabled.
        // setupChat() will then be called during onActivityResult
        if (!mBluetoothAdapter.isEnabled()) {
            Intent enableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
            startActivityForResult(enableIntent, REQUEST_ENABLE_BT);
            // Otherwise, setup the chat session
        } else {
            if (mChatService == null) setupChat();
        }
    }

    @Override
    public synchronized void onResume() {
        super.onResume();
        if (D) Log.e(TAG, "+ ON RESUME +");

        // Performing this check in onResume() covers the case in which BT was
        // not enabled during onStart(), so we were paused to enable it...
        // onResume() will be called when ACTION_REQUEST_ENABLE activity returns.
        if (mChatService != null) {
            // Only if the state is STATE_NONE, do we know that we haven't started already
            if (mChatService.getState() == BluetoothChatService.STATE_NONE) {
                // Start the Bluetooth chat services
                mChatService.start();
            }
        }
    }

    private void setupChat() {
        Log.d(TAG, "setupChat()");

        // Initialize the BluetoothChatService to perform bluetooth connections
        mChatService = new BluetoothChatService(this, mHandler);
System.out.println("你吃屎吧");
        // Initialize the buffer for outgoing messages
        mOutStringBuffer = new StringBuffer("");
    }

    @Override
    public synchronized void onPause() {
        super.onPause();
        if (D) Log.e(TAG, "- ON PAUSE -");
    }

    @Override
    public void onStop() {
        super.onStop();
        if (D) Log.e(TAG, "-- ON STOP --");
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        // Stop the Bluetooth chat services
        if (mChatService != null) mChatService.stop();
        if (D) Log.e(TAG, "--- ON DESTROY ---");
    }

    private void ensureDiscoverable() {
        if (D) Log.d(TAG, "ensure discoverable");
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);
            startActivity(discoverableIntent);
        }
    }

    /**
     * Sends a message.
     *
     * @param message A string of text to send.
     */
    private void sendMessages(String message) {
        // Check that we're actually connected before trying anything
        if (mChatService.getState() != BluetoothChatService.STATE_CONNECTED) {
            Toast.makeText(this, R.string.not_connected, Toast.LENGTH_SHORT).show();
            return;
        }

        // Check that there's actually something to send
        if (message.length() > 0) {
            // Get the message bytes and tell the BluetoothChatService to write
            byte[] send = message.getBytes();
            System.out.println(message);
            mChatService.write(send);

            // Reset out string buffer to zero and clear the edit text field
            mOutStringBuffer.setLength(0);

        }
    }

    // The action listener for the EditText widget, to listen for the return key
    private TextView.OnEditorActionListener mWriteListener =
            new TextView.OnEditorActionListener() {
                public boolean onEditorAction(TextView view, int actionId, KeyEvent event) {
                    // If the action is a key-up event on the return key, send the message
                    if (actionId == EditorInfo.IME_NULL && event.getAction() == KeyEvent.ACTION_UP) {
                        String message = view.getText().toString();
                        //sendMessage(message);
                    }
                    if (D) Log.i(TAG, "END onEditorAction");
                    return true;
                }
            };
    // The Handler that gets information back from the BluetoothChatService
    private final Handler mHandler = new Handler(Looper.getMainLooper()) {
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MESSAGE_STATE_CHANGE:
                    if (D) Log.i(TAG, "MESSAGE_STATE_CHANGE: " + msg.arg1);
                    switch (msg.arg1) {
                        case BluetoothChatService.STATE_CONNECTED:
                            mTitle.setText(R.string.title_connected_to);
                            mTitle.append(mConnectedDeviceName);
                            break;
                        case BluetoothChatService.STATE_CONNECTING:
                            mTitle.setText(R.string.title_connecting);
                            break;
                        case BluetoothChatService.STATE_LISTEN:
                        case BluetoothChatService.STATE_NONE:
                            mTitle.setText(R.string.title_not_connected);
                            break;
                    }
                    break;
                case MESSAGE_WRITE:
                    byte[] writeBuf = (byte[]) msg.obj;
                    // construct a string from the buffer
                    String writeMessage = new String(writeBuf);

                    break;
                case MESSAGE_READ: {
                    time1 = System.nanoTime();
                    byte[] readBuf = (byte[]) msg.obj;
                    // construct a string from the valid bytes in the buffer
                    int recog_time;
                    long t;
                    String color_result;
                    readMessage = new String(readBuf, 0, msg.arg1);
                    readchars = readMessage.getBytes();
                    if (readchars[0] == '1' || readchars[0] == '2' || readchars[0] == '3' || readchars[0] == '4' || readchars[0] == '5' || readchars[0] == '6') {
                        //camera.takePicture(null, null, new MyPictureCallback());

                        camera.autoFocus(new Camera.AutoFocusCallback() {
                            @Override
                            public void onAutoFocus(boolean b, Camera camera) {
                                camera.takePicture(null, null, new MyPictureCallback());
                            }
                        });

                        //sendMessages(readMessage);

                    } else if (readchars[0] == '7') {
                        colorRecognition.Get_RubikTotalColor(0, 0);
                        color_result = rubikrobot.Test_Solution(colorRecognition.color_mask);
                        recog_time = 1;//颜色识别的次数
                        t = System.nanoTime();
                        System.out.println("这是"+color_result);
                        System.out.println("这是"+colorRecognition.color_mask);
                        if(color_result==null||color_result.equals("")){
                            color_result="success";
                        }
                        while ((color_result.charAt(0) == 'E') && ((System.nanoTime() - t) < 5000 * 1.0e6))//5S
                        {
                            int x_bias = ((int) (Math.random() * 70)) - 35;//-30到30的随机数
                            int y_bias = ((int) (Math.random() * 70)) - 35;
                            colorRecognition.Get_ColorMask(x_bias, y_bias);
                        //  ColorRecognition.Analy_Error1();
                            color_result = rubikrobot.Test_Solution(colorRecognition.color_mask);
                            recog_time++;
                        }
                        if (color_result.charAt(0) != 'E') {
                            String send_string=rubikrobot.Get_Solution(colorRecognition.color_mask);
                            sendMessages(send_string);
                            //Toast.makeText(MainActivity.this ,"颜色识别结果："+colorRecognition.look_color()+"\r\n"+"颜色识别次数："+String.valueOf(recog_time)+"\r\n"+"解算公式："+send_string,Toast.LENGTH_LONG).show();
                            Toast.makeText(MainActivity.this ,"识别成功！\r\n"+"颜色识别次数："+String.valueOf(recog_time)+"\r\n"+"解算公式："+send_string+"\r\n",Toast.LENGTH_LONG).show();

                        } else {
                            //Toast.makeText(MainActivity.this ,"\r\n"+result+"\r\n"+ColorRecognition.rubiktotalcolor,Toast.LENGTH_LONG).show();
                            Toast.makeText(MainActivity.this, "经过" + String.valueOf(recog_time) + "次颜色识别，用时5S!!!!!\r\n" + colorRecognition.look_color(), Toast.LENGTH_LONG).show();
                        }

                    }
                    //Toast.makeText(MainActivity.this, "蓝牙接收到字符串" + readMessage, Toast.LENGTH_SHORT).show();
                    //sendMessages(search.solution(colorRecognition.Get_RubikTotalColor(), 21, 100, 0, 0));
                }
                break;
                case MESSAGE_DEVICE_NAME:
                    // save the connected device's name
                    mConnectedDeviceName = msg.getData().getString(DEVICE_NAME);
                    Toast.makeText(getApplicationContext(), "连接到 "
                            + mConnectedDeviceName, Toast.LENGTH_SHORT).show();
                    break;
                case MESSAGE_TOAST:
                    Toast.makeText(getApplicationContext(), msg.getData().getString(TOAST),
                            Toast.LENGTH_SHORT).show();
                    break;
            }
        }
    };


    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (D) Log.d(TAG, "onActivityResult " + resultCode);
        switch (requestCode) {
            case REQUEST_CONNECT_DEVICE:
                // When DeviceListActivity returns with a device to connect
                if (resultCode == Activity.RESULT_OK) {
                    // Get the device MAC address
                    String address = data.getExtras()
                            .getString(DeviceListActivity.EXTRA_DEVICE_ADDRESS);
                    // Get the BLuetoothDevice object
                    BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address);
                    // Attempt to connect to the device
                    mChatService.connect(device);
                }
                break;
            case REQUEST_ENABLE_BT:
                // When the request to enable Bluetooth returns
                if (resultCode == Activity.RESULT_OK) {
                    // Bluetooth is now enabled, so set up a chat session
                    setupChat();
                } else {
                    // User did not enable Bluetooth or an error occured
                    Log.d(TAG, "BT not enabled");
                    Toast.makeText(this, R.string.bt_not_enabled_leaving, Toast.LENGTH_SHORT).show();
                    finish();
                }
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.option_menu, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.scan:
                // Launch the DeviceListActivity to see devices and do scan
                Intent serverIntent = new Intent(this, DeviceListActivity.class);
                startActivityForResult(serverIntent, REQUEST_CONNECT_DEVICE);
                return true;
            case R.id.discoverable:
                // Ensure this device is discoverable by others
                ensureDiscoverable();
            /*
            colorRecognition.GetPhoto_fromSD();
            long t1=System.nanoTime();
            String a=colorRecognition.Get_Colorstate(10, 10);
            long t3=(System.nanoTime()-t1)/1000;
            Toast.makeText(MainActivity.this,"\r\n"+String.valueOf(t3)+"uS",Toast.LENGTH_LONG).show();
            */
                return true;
        }
        return false;
    }

    /**
     *
     */

    private final class MyPictureCallback implements Camera.PictureCallback {

        @Override
        public void onPictureTaken(byte[] data, Camera camera) {
            try {
                bundle = new Bundle();
                bundle.putByteArray("bytes", data);
                saveToSDCard(data);
                camera.startPreview();
                time11 = (int) (System.nanoTime() / 1.0e6 - time10);
                // Toast.makeText(getApplicationContext(), String.valueOf(time11),Toast.LENGTH_LONG).show();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     *
     */
    public void saveToSDCard(byte[] data) throws IOException {
        /*
        Date date = new Date();

        SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmss");
        String filename = format.format(date) + ".jpg";
        File fileFolder = new File(Environment.getExternalStorageDirectory()
                + "/finger/");
        if (!fileFolder.exists()) {
            fileFolder.mkdir();
        }
         File jpgFile = new File(fileFolder, filename);*/
        Change_Readchars();
        File jpgFile = new File("/storage/emulated/0/Android/data/com.example.rubikrobot/cache/", String.valueOf(photo_order++) + ".jpg");
        FileOutputStream outputStream = new FileOutputStream(jpgFile);
        outputStream.write(data);
        outputStream.close();


    }


    private int getSurfaceId(SurfaceHolder holder) {
        if (holder.equals(cameraSurface.getHolder())) {
            return 1;
        } else if (holder.equals(locateSurface.getHolder())) {
            return 2;
        } else {
            return -1;
        }
    }


    private final class SurfaceCallback implements SurfaceHolder.Callback {

        @Override
        public void surfaceCreated(SurfaceHolder holder) {
            try {
                camera = Camera.open();
                camera.setPreviewDisplay(holder);
                // camera.setDisplayOrientation(getPreviewDegree(MainActivity.this));
                camera.startPreview();
                //tryDrawing(holder);
                RequestPermission();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        @Override
        public void surfaceChanged(SurfaceHolder holder, int format, int width,
                                   int height) {

            int id = getSurfaceId(holder);
           //camera.setDisplayOrientation(90);
            camera.setDisplayOrientation(getPreviewDegree(MainActivity.this));
            Surface surface = holder.getSurface();

            switch (id) {
                case 1: {
                    parameters = camera.getParameters();
                    parameters.setPictureFormat(PixelFormat.JPEG);

                    /*
                    //获取摄像头支持的PreviewSize列表
                    List<Camera.Size> supportedpreviewSizes = parameters.getSupportedPreviewSizes();
                    for (int i = 0; i < supportedpreviewSizes.size(); i++) {
                        Log.e("预览尺寸", " Supported Size. Width: " + supportedpreviewSizes.get(i).width + " height : " + supportedpreviewSizes.get(i).height);
                        Toast.makeText(MainActivity.this, "预览尺寸：\r\n"+"宽度:"+String.valueOf(supportedpreviewSizes.get(i).width)+"\r\n"+"高度："+String.valueOf(supportedpreviewSizes.get(i).height), Toast.LENGTH_LONG).show();
                    }

                    //获取摄像头支持的照片大小
                    List<Camera.Size> supportedPictureSizes = parameters.getSupportedPictureSizes();
                    for (int i = 0; i < supportedPictureSizes.size(); i++) {

                        Log.e("照片尺寸", " Supported Size. Width: " + supportedPictureSizes.get(i).width + " height : " + supportedPictureSizes.get(i).height);
                        Toast.makeText(MainActivity.this, "图片尺寸：\r\n"+"宽度:"+String.valueOf(supportedPictureSizes.get(i).width)+"\r\n"+"高度："+String.valueOf(supportedPictureSizes.get(i).height), Toast.LENGTH_LONG).show();
                    }

                    */

                    // parameters.setPreviewSize(1280,720);
                    //parameters.setPreviewFrameRate(5);
                    parameters.setPictureSize(1024,768);
                    //Toast.makeText(MainActivity.this, "图片width为："+String.valueOf(width)+"图片height为："+String.valueOf(height)+"   ", Toast.LENGTH_LONG).show();
                    parameters.setJpegQuality(100);
                    // parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
                    camera.setParameters(parameters);
                    camera.startPreview();
                    //camera.cancelAutoFocus();
                    //camera.startPreview();
                    // List <int>supportedPreviewSizes = parameters.getSupportedPreviewSizes();
                }
                case 2: {
                    // 获取屏幕分辨率尺寸
                    //wm = (WindowManager) this.getSystemService(Context.WINDOW_SERVICE);
                    screenWidth = wm.getDefaultDisplay().getWidth();
                    screenHeight = wm.getDefaultDisplay().getHeight();
                    System.out.println("高宽"+screenHeight+""+screenWidth);
                    //Toast.makeText(MainActivity.this, String.valueOf(screenWidth) + " " + String.valueOf(screenHeight), Toast.LENGTH_LONG).show();
                    //计算预览界面和硬件平台的标定位置中心，这里屏幕中心
                    locate_x = screenWidth / 2;
                    locate_y = screenHeight / 2;
                    //tryDrawing(holder);

                }
                break;

                default: {

                }
                break;

            }
        }

        void RequestPermission() {
            if (ContextCompat.checkSelfPermission(MainActivity.this, android.Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
                ActivityCompat.requestPermissions(MainActivity.this, new String[]{android.Manifest.permission.CAMERA}, 1);
                Log.d(TAG, "RequestPermission");
            } else {
                Log.d(TAG, "失败");
            }
        }


        @Override
        public void surfaceDestroyed(SurfaceHolder holder) {
            if (camera != null) {
                camera.release();
                camera = null;
            }
        }


        private void tryDrawing(SurfaceHolder holder) {
            Log.i(TAG, "Trying to draw...");

            Canvas canvas = holder.lockCanvas();
            if (canvas == null)
            {
                Log.e(TAG, "Cannot draw onto the canvas as it's null");
            }
            else
            {

                Log.i(TAG, "Drawing...");

                Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
                paint.setColor(Color.BLACK);
                paint.setStyle(Paint.Style.FILL);
                //paint.setShadowLayer(50 /2 + 1, 0, 0, Color.RED);
                //canvas.drawCircle(screenWidth/2,screenHeight/2, 50, paint);
                paint.setStrokeWidth(1); //画笔粗细
                canvas.drawLine(locate_x - locate_x, locate_y, locate_x + locate_x, locate_y, paint);
                canvas.drawLine(locate_x, locate_y - locate_y, locate_x, locate_y + locate_y, paint);
                holder.unlockCanvasAndPost(canvas);

            }

        }

    }

    public static int getPreviewDegree(Activity activity) {

        int rotation = activity.getWindowManager().getDefaultDisplay()
                .getRotation();
        int degree = 0;
        System.out.println(rotation+"这是rotation");
        switch (rotation) {
            case Surface.ROTATION_0:
                degree = 90;
                break;
            case Surface.ROTATION_90:
                degree = 0;
                break;
            case Surface.ROTATION_180:
                degree = 270;
                break;
            case Surface.ROTATION_270:
                degree = 180;
                break;
        }

        return degree;
    }


    public void Change_Readchars() {
        switch (readchars[0]) {
            case '1': {
                photo_order = 1;
            }
            break;
            case '2': {
                photo_order = 2;
            }
            break;

            case '3': {
                photo_order = 3;
            }
            break;

            case '4': {
                photo_order = 4;
            }
            break;

            case '5': {
                photo_order = 5;
            }
            break;

            case '6': {
                photo_order = 6;
            }
            break;
            default: {

            }
            break;

        }

    }


//    public boolean onTouchEvent(MotionEvent event) {
//        int Action = event.getAction();
//
//        //按下屏幕
//        if (Action == MotionEvent.ACTION_DOWN)
//        {
//
//            colorRecognition.GetPhoto_fromSD();  //读取SD中的6张图片信息
//            colorRecognition.Get_color_note(0, 0);
//            String result = rubikrobot.Test_Solution(colorRecognition.color_mask);
//            int recog_time = 1;//颜色识别的次数
//            long t = System.nanoTime();
//            int x_bias = 0;
//            int y_bias = 0;
//
//            while ((result.charAt(0) == 'E') && ((System.nanoTime() - t) < 5000 * 1.0e6))//1S
//            {
//                x_bias = ((int) (Math.random() * 70)) - 35;//-35到35的随机数
//                y_bias = ((int) (Math.random() * 70)) - 35;
//                colorRecognition.Get_color_note(x_bias, y_bias);
//                result = rubikrobot.Test_Solution(colorRecognition.color_mask);
//                recog_time++;
//            }
//
//            colorRecognition.Get_color_note(x_bias, y_bias);
//
//            if (result.charAt(0) != 'E')//没有错误
//            {
//                //sendMessages(rubikrobot.Get_Solution(color_statement));
//                String send_string = rubikrobot.Get_Solution(colorRecognition.color_mask);
//                Toast.makeText(MainActivity.this, "颜色识别成功！\r\n" + "识别结果：" + colorRecognition.look_colo() + "\r\n" + "颜色识别次数：" + String.valueOf(recog_time) + "\r\n" + "解算公式：" + send_string + "\r\n" + "\r\n", Toast.LENGTH_LONG).show();
//            }
//
//            else
//            {
//                //Toast.makeText(MainActivity.this ,"\r\n"+result+"\r\n"+ColorRecognition.rubiktotalcolor,Toast.LENGTH_LONG).show();
//                Toast.makeText(MainActivity.this, "颜色识别失败！\r\n" + "经过" + String.valueOf(recog_time) + "次颜色识别，用时5S！！\r\n" + colorRecognition.look_colo() + "\r\n", Toast.LENGTH_LONG).show();
//            }
//
//
//
//              /*  camera.autoFocus(new Camera.AutoFocusCallback() {
//                    @Override
//                    public void onAutoFocus(boolean b, Camera camera) {
//                        camera.takePicture(null, null, new MyPictureCallback());
//                    }
//                });
//               */
//
//        }
//        return true;
//    }
}



\n
./src/main//java//com//example//rubikrobot//Solution//CoordCube.java
\n
package com.example.rubikrobot.Solution;

import java.io.*;
import java.nio.channels.*;//定义了各种通道，这些通道表示到能够执行 I/O 操作的实体（如文件和套接字）的连接；定义了用于多路复用的、非阻塞 I/O 操作的选择器
import java.nio.*;

class CoordCube {

	static final int N_MOVES = 18;
	static final int N_MOVES2 = 10;
	static final int N_SLICE = 495;
	static final int N_TWIST = 2187;
	static final int N_TWIST_SYM = 324;
	static final int N_FLIP = 2048;
	static final int N_FLIP_SYM = 336;
	static final int N_PERM = 40320;
	static final int N_PERM_SYM = 2768;
	static final int N_MPERM = 24;
	static final int N_COMB = 70;
	static final int N_UDSLICEFLIP_SYM = 64430;

	static final long N_HUGE = N_UDSLICEFLIP_SYM * N_TWIST * 70L;// 9,863,588,700
	static final int N_FULL_5 = N_UDSLICEFLIP_SYM * N_TWIST / 5;
	static final int N_HUGE_16 = (int) ((N_HUGE + 15) / 16);
	static final int N_HUGE_5 = (int) (N_HUGE / 5);// 1,972,717,740

	// XMove = Move Table
	// XPrun = Pruning Table
	// XConj = Conjugate Table

	// full phase1
	static int[][] UDSliceFlipMove = Search.USE_FULL_PRUN ? new int[N_UDSLICEFLIP_SYM][N_MOVES]
			: null;
	static char[][] TwistMoveF = Search.USE_FULL_PRUN ? new char[N_TWIST][N_MOVES]
			: null;
	static char[][] TwistConj = Search.USE_FULL_PRUN ? new char[N_TWIST][16]
			: null;
	static byte[] UDSliceFlipTwistPrunP = null; // Search.USE_FULL_PRUN ? new
												// byte[N_UDSLICEFLIP_SYM *
												// N_TWIST / 5] : null;
	static byte[] HugePrunP = null; // Search.USE_HUGE_PRUN ? new byte[N_HUGE_5]
									// : null;

	// phase1
	static char[][] UDSliceMove = new char[N_SLICE][N_MOVES];
	static char[][] TwistMove = new char[N_TWIST_SYM][N_MOVES];
	static char[][] FlipMove = new char[N_FLIP_SYM][N_MOVES];
	static char[][] UDSliceConj = new char[N_SLICE][8];
	static int[] UDSliceTwistPrun = new int[N_SLICE * N_TWIST_SYM / 8 + 1];
	static int[] UDSliceFlipPrun = new int[N_SLICE * N_FLIP_SYM / 8];
	static int[] TwistFlipPrun = Search.USE_TWIST_FLIP_PRUN ? new int[N_FLIP
			* N_TWIST_SYM / 8] : null;

	// phase2
	static char[][] CPermMove = new char[N_PERM_SYM][N_MOVES];
	static char[][] EPermMove = new char[N_PERM_SYM][N_MOVES2];
	static char[][] MPermMove = new char[N_MPERM][N_MOVES2];
	static char[][] MPermConj = new char[N_MPERM][16];
	static char[][] CCombMove = new char[N_COMB][N_MOVES];
	static char[][] CCombConj = new char[N_COMB][16];
	static int[] MCPermPrun = new int[N_MPERM * N_PERM_SYM / 8];
	static int[] MEPermPrun = new int[N_MPERM * N_PERM_SYM / 8];
	static int[] EPermCCombPrun = new int[N_COMB * N_PERM_SYM / 8];

	static void setPruning(int[] table, int index, int value) {
		table[index >> 3] ^= (0xf ^ value) << ((index & 7) << 2);
	}

	static int getPruning(int[] table, int index) {
		return table[index >> 3] >> ((index & 7) << 2) & 0xf;
	}

	static void setPruning2(int[] table, long index, int value) {
		table[(int) (index >> 4)] ^= (0x3 ^ value) << ((index & 0xf) << 1);
	}

	static int getPruning2(int[] table, long index) {
		return table[(int) (index >> 4)] >> ((index & 0xf) << 1) & 0x3;
	}

	static char[] tri2bin = new char[243];

	static {
		for (int i = 0; i < 243; i++) {
			int val = 0;
			int l = i;
			for (int j = 0; j < 5; j++) {
				val |= (l % 3) << (j << 1);
				l /= 3;
			}
			tri2bin[i] = (char) val;
		}
	}

	static int getPruningP(byte[] table, long index, final long THRESHOLD) {
		if (index < THRESHOLD) {
			return tri2bin[table[(int) (index >> 2)] & 0xff] >> ((index & 3) << 1) & 3;
		} else {
			return tri2bin[table[(int) (index - THRESHOLD)] & 0xff] >> 8 & 3;
		}
	}

	static void packPrunTable(int[] PrunTable, ByteBuffer buf,
			final long PACKED_SIZE) {
		for (long i = 0; i < PACKED_SIZE; i++) {
			int n = 1;
			int value = 0;
			for (int j = 0; j < 4; j++) {
				value += n * getPruning2(PrunTable, i << 2 | j);
				n *= 3;
			}
			value += n * getPruning2(PrunTable, (PACKED_SIZE << 2) + i);
			buf.put((byte) value);
		}
	}

	static void initUDSliceMoveConj() {
		CubieCube c = new CubieCube();
		CubieCube d = new CubieCube();
		for (int i = 0; i < N_SLICE; i++) {
			c.setUDSlice(i);
			for (int j = 0; j < N_MOVES; j += 3) {
				CubieCube.EdgeMult(c, CubieCube.moveCube[j], d);
				UDSliceMove[i][j] = (char) d.getUDSlice();
			}
			for (int j = 0; j < 16; j += 2) {
				CubieCube.EdgeConjugate(c, CubieCube.SymInv[j], d);
				UDSliceConj[i][j >> 1] = (char) (d.getUDSlice() & 0x1ff);
			}
		}
		for (int i = 0; i < N_SLICE; i++) {
			for (int j = 0; j < N_MOVES; j += 3) {
				int udslice = UDSliceMove[i][j];
				for (int k = 1; k < 3; k++) {
					int cx = UDSliceMove[udslice & 0x1ff][j];
					udslice = Util.permMult[udslice >> 9][cx >> 9] << 9 | cx
							& 0x1ff;
					UDSliceMove[i][j + k] = (char) udslice;
				}
			}
		}
	}

	static void initFlipMove() {
		CubieCube c = new CubieCube();
		CubieCube d = new CubieCube();
		for (int i = 0; i < N_FLIP_SYM; i++) {
			c.setFlip(CubieCube.FlipS2R[i]);
			for (int j = 0; j < N_MOVES; j++) {
				CubieCube.EdgeMult(c, CubieCube.moveCube[j], d);
				FlipMove[i][j] = (char) d.getFlipSym();
			}
		}
	}

	static void initTwistMove() {
		CubieCube c = new CubieCube();
		CubieCube d = new CubieCube();
		for (int i = 0; i < N_TWIST_SYM; i++) {
			c.setTwist(CubieCube.TwistS2R[i]);
			for (int j = 0; j < N_MOVES; j++) {
				CubieCube.CornMult(c, CubieCube.moveCube[j], d);
				TwistMove[i][j] = (char) d.getTwistSym();
			}
		}
	}

	static void initCPermMove() {
		CubieCube c = new CubieCube();
		CubieCube d = new CubieCube();
		for (int i = 0; i < N_PERM_SYM; i++) {
			c.setCPerm(CubieCube.EPermS2R[i]);
			for (int j = 0; j < N_MOVES; j++) {
				CubieCube.CornMult(c, CubieCube.moveCube[j], d);
				CPermMove[i][j] = (char) d.getCPermSym();
			}
		}
	}

	static void initEPermMove() {
		CubieCube c = new CubieCube();
		CubieCube d = new CubieCube();
		for (int i = 0; i < N_PERM_SYM; i++) {
			c.setEPerm(CubieCube.EPermS2R[i]);
			for (int j = 0; j < N_MOVES2; j++) {
				CubieCube.EdgeMult(c, CubieCube.moveCube[Util.ud2std[j]], d);
				EPermMove[i][j] = (char) d.getEPermSym();
			}
		}
	}

	static void initMPermMoveConj() {
		CubieCube c = new CubieCube();
		CubieCube d = new CubieCube();
		for (int i = 0; i < N_MPERM; i++) {
			c.setMPerm(i);
			for (int j = 0; j < N_MOVES2; j++) {
				CubieCube.EdgeMult(c, CubieCube.moveCube[Util.ud2std[j]], d);
				MPermMove[i][j] = (char) d.getMPerm();
			}
			for (int j = 0; j < 16; j++) {
				CubieCube.EdgeConjugate(c, CubieCube.SymInv[j], d);
				MPermConj[i][j] = (char) d.getMPerm();
			}
		}
	}

	static void initCombMoveConj() {
		CubieCube c = new CubieCube();
		CubieCube d = new CubieCube();
		for (int i = 0; i < N_COMB; i++) {
			c.setCComb(i);
			for (int j = 0; j < N_MOVES; j++) {
				CubieCube.CornMult(c, CubieCube.moveCube[j], d);
				CCombMove[i][j] = (char) d.getCComb();
			}
			for (int j = 0; j < 16; j++) {
				CubieCube.CornConjugate(c, CubieCube.SymInv[j], d);
				CCombConj[i][j] = (char) d.getCComb();
			}
		}
	}

	static void initUDSliceFlipMove() {
		CubieCube c = new CubieCube();
		CubieCube d = new CubieCube();
		for (int i = 0; i < N_UDSLICEFLIP_SYM; i++) {
			c.setUDSliceFlip(CubieCube.UDSliceFlipS2R[i]);
			int udslice = CubieCube.UDSliceFlipS2R[i] >> 11;
			for (int j = 0; j < N_MOVES; j++) {
				CubieCube.EdgeMult(c, CubieCube.moveCube[j], d);
				// UDSliceFlipMove[i][j] = d.getUDSliceFlipSym();

				int flip = d.getFlipSym();
				int fsym = flip & 0x7;
				flip >>= 3;
				int udsliceflip = CubieCube.FlipSlice2UDSliceFlip[flip
						* N_SLICE
						+ UDSliceConj[UDSliceMove[udslice][j] & 0x1ff][fsym]];
				UDSliceFlipMove[i][j] = udsliceflip & 0xfffffff0
						| CubieCube.SymMult[udsliceflip & 0xf][fsym << 1];
			}
		}
	}

	static void initTwistMoveConj() {
		CubieCube c = new CubieCube();
		CubieCube d = new CubieCube();
		for (int i = 0; i < N_TWIST; i++) {
			c.setTwist(i);
			for (int j = 0; j < N_MOVES; j += 3) {
				CubieCube.CornMult(c, CubieCube.moveCube[j], d);
				TwistMoveF[i][j] = (char) d.getTwist();
			}
			for (int j = 0; j < 16; j++) {
				CubieCube.CornConjugate(c, CubieCube.SymInv[j], d);
				TwistConj[i][j] = (char) d.getTwist();
			}
		}
		for (int i = 0; i < N_TWIST; i++) {
			for (int j = 0; j < N_MOVES; j += 3) {
				int twist = TwistMoveF[i][j];
				for (int k = 1; k < 3; k++) {
					twist = TwistMoveF[twist][j];
					TwistMoveF[i][j + k] = (char) twist;
				}
			}
		}
	}

	static void initTwistFlipPrun() {
		int depth = 0;
		int done = 1;
		boolean inv;
		int select;
		int check;
		final int N_SIZE = N_FLIP * N_TWIST_SYM;
		for (int i = 0; i < N_SIZE / 8; i++) {
			TwistFlipPrun[i] = -1;
		}
		setPruning(TwistFlipPrun, 0, 0);

		while (done < N_SIZE) {
			inv = depth > 6;
			select = inv ? 0xf : depth;
			check = inv ? depth : 0xf;
			depth++;
			int val = 0;
			for (int i = 0; i < N_SIZE; i++, val >>= 4) {
				if ((i & 7) == 0) {
					val = TwistFlipPrun[i >> 3];
					if (!inv && val == -1) {
						i += 7;
						continue;
					}
				}
				if ((val & 0xf) != select) {
					continue;
				}
				int twist = i >> 11;
				int flip = CubieCube.FlipR2S[i & 0x7ff];
				int fsym = flip & 7;
				flip >>= 3;
				for (int m = 0; m < N_MOVES; m++) {
					int twistx = TwistMove[twist][m];
					int tsymx = twistx & 7;
					twistx >>= 3;
					int flipx = FlipMove[flip][CubieCube.Sym8Move[m << 3 | fsym]];
					int fsymx = CubieCube.Sym8MultInv[CubieCube.Sym8Mult[flipx
							& 7 | fsym << 3] << 3
							| tsymx];
					flipx >>= 3;
					int idx = twistx << 11
							| CubieCube.FlipS2RF[flipx << 3 | fsymx];
					if (getPruning(TwistFlipPrun, idx) != check) {
						continue;
					}
					done++;
					if (inv) {
						setPruning(TwistFlipPrun, i, depth);
						break;
					}
					setPruning(TwistFlipPrun, idx, depth);
					char sym = CubieCube.SymStateTwist[twistx];
					if (sym == 1) {
						continue;
					}
					for (int k = 0; k < 8; k++) {
						if ((sym & 1 << k) == 0) {
							continue;
						}
						int idxx = twistx << 11
								| CubieCube.FlipS2RF[flipx << 3
										| CubieCube.Sym8MultInv[fsymx << 3 | k]];
						if (getPruning(TwistFlipPrun, idxx) == 0xf) {
							setPruning(TwistFlipPrun, idxx, depth);
							done++;
						}
					}
				}
			}
			// System.out.println(String.format("%2d%10d", depth, done));
		}
	}

	static void initRawSymPrun(int[] PrunTable, final int INV_DEPTH,
			final char[][] RawMove, final char[][] RawConj,
			final char[][] SymMove, final char[] SymState, final int PrunFlag) {

		final int SYM_SHIFT = PrunFlag & 0xf;
		final boolean SymSwitch = ((PrunFlag >> 4) & 1) == 1;
		final boolean MoveMapSym = ((PrunFlag >> 5) & 1) == 1;
		final boolean MoveMapRaw = ((PrunFlag >> 6) & 1) == 1;

		final int SYM_MASK = (1 << SYM_SHIFT) - 1;
		final int N_RAW = RawMove.length;
		final int N_SYM = SymMove.length;
		final int N_SIZE = N_RAW * N_SYM;
		final int N_MOVES = MoveMapRaw ? 10 : RawMove[0].length;

		for (int i = 0; i < (N_RAW * N_SYM + 7) / 8; i++) {
			PrunTable[i] = -1;
		}
		setPruning(PrunTable, 0, 0);

		int depth = 0;
		int done = 1;

		while (done < N_SIZE) {
			boolean inv = depth > INV_DEPTH;
			int select = inv ? 0xf : depth;
			int check = inv ? depth : 0xf;
			depth++;
			int val = 0;
			for (int i = 0; i < N_SIZE; i++, val >>= 4) {
				if ((i & 7) == 0) {
					val = PrunTable[i >> 3];
					if (!inv && val == -1) {
						i += 7;
						continue;
					}
				}
				if ((val & 0xf) != select) {
					continue;
				}
				int raw = i % N_RAW;
				int sym = i / N_RAW;
				for (int m = 0; m < N_MOVES; m++) {
					int symx = SymMove[sym][MoveMapSym ? Util.ud2std[m] : m];
					int rawx = RawConj[RawMove[raw][MoveMapRaw ? Util.ud2std[m]
							: m] & 0x1ff][symx & SYM_MASK];
					symx >>= SYM_SHIFT;
					int idx = symx * N_RAW + rawx;
					if (getPruning(PrunTable, idx) != check) {
						continue;
					}
					done++;
					if (inv) {
						setPruning(PrunTable, i, depth);
						break;
					}
					setPruning(PrunTable, idx, depth);
					for (int j = 1, symState = SymState[symx]; (symState >>= 1) != 0; j++) {
						if ((symState & 1) != 1) {
							continue;
						}
						int idxx = symx
								* N_RAW
								+ RawConj[rawx][j
										^ (SymSwitch ? CubieCube.e2c[j] : 0)];
						if (getPruning(PrunTable, idxx) == 0xf) {
							setPruning(PrunTable, idxx, depth);
							done++;
						}
					}
				}
			}
			// System.out.println(String.format("%2d%10d", depth, done));
		}
	}

	static boolean loadPrunPTable(byte[] table, String fileName) {
		final int length = table.length;
		try {
			RandomAccessFile raf = new RandomAccessFile(fileName, "r");
			FileChannel channel = raf.getChannel();
			MappedByteBuffer buffer = channel.map(
					FileChannel.MapMode.READ_ONLY, 0, length);
			for (int i = 0; i < length; i++) {
				table[i] = buffer.get();
			}
			raf.close();
			return true;
		} catch (FileNotFoundException e) {
			// e.printStackTrace();
		} catch (IOException ioe) {
			ioe.printStackTrace();
		}
		return false;
	}

	static void packAndSavePrunPTable(int[] table, String fileName,
			int FILE_SIZE) {
		try {
			RandomAccessFile raf = new RandomAccessFile(fileName, "rw");
			raf.setLength(FILE_SIZE);
			FileChannel channel = raf.getChannel();
			MappedByteBuffer buffer = channel.map(
					FileChannel.MapMode.READ_WRITE, 0, FILE_SIZE);
			packPrunTable(table, buffer, FILE_SIZE);
			raf.close();
		} catch (IOException ioe) {
			ioe.printStackTrace();
		}
	}

	private static final int MAXDEPTH = 15;

	static void initUDSliceFlipTwistPrun() {
		UDSliceFlipTwistPrunP = new byte[N_FULL_5];
		if (loadPrunPTable(UDSliceFlipTwistPrunP, "FullTable.prunP")) {
			return;
		}
		UDSliceFlipTwistPrunP = null;
		int[] UDSliceFlipTwistPrun = new int[N_UDSLICEFLIP_SYM * N_TWIST / 16
				+ 1];

		final int N_SIZE = N_TWIST * N_UDSLICEFLIP_SYM;

		for (int i = 0; i < (N_SIZE + 15) / 16; i++) {
			UDSliceFlipTwistPrun[i] = -1;
		}
		setPruning2(UDSliceFlipTwistPrun, 0, 0);

		int depth = 0;
		int done = 1;

		while (done < N_SIZE) {
			boolean inv = depth > 8;
			int select = inv ? 0x3 : depth % 3;
			int check = inv ? depth % 3 : 0x3;
			depth++;
			int depm3 = depth % 3;
			if (depth >= MAXDEPTH) {
				break;
			}
			for (int i = 0; i < N_SIZE;) {
				int val = UDSliceFlipTwistPrun[i >> 4];
				if (!inv && val == -1) {
					i += 16;
					continue;
				}
				for (int end = Math.min(i + 16, N_SIZE); i < end; i++, val >>= 2) {
					if ((val & 0x3) != select) {
						continue;
					}
					int raw = i % N_TWIST;
					int sym = i / N_TWIST;
					for (int m = 0; m < N_MOVES; m++) {
						int symx = UDSliceFlipMove[sym][m];
						int rawx = TwistConj[TwistMoveF[raw][m]][symx & 0xf];
						symx >>= 4;
						int idx = symx * N_TWIST + rawx;
						if (getPruning2(UDSliceFlipTwistPrun, idx) != check) {
							continue;
						}
						done++;
						if (inv) {
							setPruning2(UDSliceFlipTwistPrun, i, depm3);
							break;
						}
						setPruning2(UDSliceFlipTwistPrun, idx, depm3);
						for (int j = 1, symState = CubieCube.SymStateUDSliceFlip[symx]; (symState >>= 1) != 0; j++) {
							if ((symState & 1) != 1) {
								continue;
							}
							int idxx = symx * N_TWIST + TwistConj[rawx][j];
							if (getPruning2(UDSliceFlipTwistPrun, idxx) == 0x3) {
								setPruning2(UDSliceFlipTwistPrun, idxx, depm3);
								done++;
							}
						}
					}
				}
			}
			System.out.println(String.format("%2d%10d", depth, done));
		}

		packAndSavePrunPTable(UDSliceFlipTwistPrun, "FullTable.prunP", N_FULL_5);
		UDSliceFlipTwistPrun = null;
		UDSliceFlipTwistPrunP = new byte[N_FULL_5];
		if (!loadPrunPTable(UDSliceFlipTwistPrunP, "FullTable.prunP")) {
			System.out.println("Error Loading FullTable.prunP");
			throw new RuntimeException("Error Loading FullTable.prunP");
		}
	}

	static void initHugePrun() {
		HugePrunP = new byte[N_HUGE_5];
		if (loadPrunPTable(HugePrunP, "HugeTable.prunP")) {
			return;
		}
		HugePrunP = null;

		final long N_SIZE = N_HUGE;
		final long N_RAW = N_TWIST * N_COMB;

		int[] HugePrun = new int[N_HUGE_16];

		for (int i = 0; i < N_HUGE_16; i++) {
			HugePrun[i] = -1;
		}
		setPruning2(HugePrun, 0, 0);

		int depth = 0;
		long done = 1;

		while (done < N_SIZE) {
			boolean inv = depth > 9;
			int select = inv ? 0x3 : depth % 3;
			int check = inv ? depth % 3 : 0x3;
			depth++;
			int depm3 = depth % 3;
			for (long i = 0; i < N_SIZE;) {
				int val = HugePrun[(int) (i >> 4)];
				if (!inv && val == -1) {
					i += 16;
					continue;
				}
				for (long end = Math.min(i + 16, N_SIZE); i < end; i++, val >>= 2) {
					if ((val & 0x3) != select) {
						continue;
					}
					int raw = (int) (i % N_RAW);
					int sym = (int) (i / N_RAW);
					for (int m = 0; m < N_MOVES; m++) {
						int symx = UDSliceFlipMove[sym][m];
						int rawx = TwistConj[TwistMoveF[raw / N_COMB][m]][symx & 0xf]
								* N_COMB
								+ CCombConj[CCombMove[raw % N_COMB][m]][symx & 0xf];
						symx >>= 4;
						long idx = symx * N_RAW + rawx;
						if (getPruning2(HugePrun, idx) != check) {
							continue;
						}
						done++;
						if ((done & 0x1fffff) == 0) {
							System.out.print(done + "\r");
						}
						if (inv) {
							setPruning2(HugePrun, i, depm3);
							break;
						}
						setPruning2(HugePrun, idx, depm3);
						for (int j = 1, symState = CubieCube.SymStateUDSliceFlip[symx]; (symState >>= 1) != 0; j++) {
							if ((symState & 1) != 1) {
								continue;
							}
							long idxx = symx * N_RAW
									+ TwistConj[rawx / N_COMB][j] * N_COMB
									+ CCombConj[rawx % N_COMB][j];
							if (getPruning2(HugePrun, idxx) == 0x3) {
								setPruning2(HugePrun, idxx, depm3);
								done++;
							}
						}
					}
				}
			}
			System.out.println(String.format("%2d%12d", depth, done));
		}

		packAndSavePrunPTable(HugePrun, "HugeTable.prunP", N_HUGE_5);
		HugePrun = null;
		HugePrunP = new byte[N_HUGE_5];
		if (!loadPrunPTable(HugePrunP, "HugeTable.prunP")) {
			System.out.println("Error Loading HugeTable.prunP");
			throw new RuntimeException("Error Loading HugeTable.prunP");
		}
	}

	static void initSliceTwistPrun() {
		initRawSymPrun(UDSliceTwistPrun, 6, UDSliceMove, UDSliceConj,
				TwistMove, CubieCube.SymStateTwist, 0x3);
	}

	static void initSliceFlipPrun() {
		initRawSymPrun(UDSliceFlipPrun, 6, UDSliceMove, UDSliceConj, FlipMove,
				CubieCube.SymStateFlip, 0x3);
	}

	static void initMEPermPrun() {
		initRawSymPrun(MEPermPrun, 7, MPermMove, MPermConj, EPermMove,
				CubieCube.SymStatePerm, 0x4);
	}

	static void initMCPermPrun() {
		initRawSymPrun(MCPermPrun, 10, MPermMove, MPermConj, CPermMove,
				CubieCube.SymStatePerm, 0x34);
	}

	static void initPermCombPrun() {
		initRawSymPrun(EPermCCombPrun, 8, CCombMove, CCombConj, EPermMove,
				CubieCube.SymStatePerm, 0x44);
	}

	int twist;
	int tsym;
	int flip;
	int fsym;
	int slice;
	int prun;

	CoordCube() {
	}

	CoordCube(CoordCube cc) {
		set(cc);
	}

	void set(CoordCube node) {
		this.twist = node.twist;
		this.tsym = node.tsym;
		this.flip = node.flip;
		this.fsym = node.fsym;
		this.slice = node.slice;
		this.prun = node.prun;
	}

	int getPackedPruning(boolean isPhase1) {
		int prunm3 = 0;
		if (Search.USE_HUGE_PRUN && !isPhase1) {
			prunm3 = getPruningP(HugePrunP, flip * ((long) N_TWIST) * N_COMB
					+ TwistConj[twist][fsym] * N_COMB + CCombConj[tsym][fsym],
					N_HUGE_5 * 4L);
		} else {
			prunm3 = getPruningP(UDSliceFlipTwistPrunP, flip * N_TWIST
					+ TwistConj[twist][fsym], N_UDSLICEFLIP_SYM * N_TWIST / 5
					* 4);
		}
		prun = 0;
		CoordCube tmp1 = new CoordCube();
		CoordCube tmp2 = new CoordCube();
		tmp1.set(this);
		tmp1.prun = prunm3;
		while (tmp1.twist != 0 || tmp1.flip != 0 || tmp1.tsym != 0 && !isPhase1) {
			++prun;
			if (tmp1.prun == 0) {
				tmp1.prun = 3;
			}
			for (int m = 0; m < 18; m++) {
				int gap = tmp2.doMovePrun(tmp1, m, isPhase1);
				if (gap < tmp1.prun) {
					tmp1.set(tmp2);
					break;
				}
			}
		}
		return prun;
	}

	void calcPruning(boolean isPhase1) {
		if (Search.USE_FULL_PRUN || Search.USE_HUGE_PRUN) {
			getPackedPruning(isPhase1);
		} else {
			prun = Math.max(
					Math.max(
							getPruning(UDSliceTwistPrun, twist * N_SLICE
									+ UDSliceConj[slice & 0x1ff][tsym]),
							getPruning(UDSliceFlipPrun, flip * N_SLICE
									+ UDSliceConj[slice & 0x1ff][fsym])),
					Search.USE_TWIST_FLIP_PRUN ? getPruning(TwistFlipPrun,
							twist << 11
									| CubieCube.FlipS2RF[flip << 3
											| CubieCube.Sym8MultInv[fsym << 3
													| tsym]]) : 0);
		}
	}

	void set(CubieCube cc) {
		if (Search.USE_FULL_PRUN || Search.USE_HUGE_PRUN) {
			twist = cc.getTwist();
			flip = cc.getUDSliceFlipSym();
			slice = cc.getUDSlice();
			fsym = flip & 0xf;
			flip >>= 4;
			if (Search.USE_HUGE_PRUN) {
				tsym = cc.getCComb(); // tsym -> CComb
			}
		} else {
			twist = cc.getTwistSym();
			flip = cc.getFlipSym();
			slice = cc.getUDSlice();
			tsym = twist & 7;
			twist = twist >> 3;
			fsym = flip & 7;
			flip = flip >> 3;
		}
	}

	/**
	 * @return 0: Success 1: Try Next Power 2: Try Next Axis
	 */
	int doMovePrun(CoordCube cc, int m, boolean isPhase1) {
		if (Search.USE_FULL_PRUN) {
			twist = TwistMoveF[cc.twist][m];
			flip = UDSliceFlipMove[cc.flip][CubieCube.SymMove[cc.fsym][m]];
			fsym = CubieCube.SymMult[flip & 0xf][cc.fsym];
			flip >>= 4;

			int prunm3;
			if (Search.USE_HUGE_PRUN && !isPhase1) {
				tsym = CCombMove[cc.tsym][m];
				prunm3 = getPruningP(HugePrunP, flip * ((long) N_TWIST)
						* N_COMB + TwistConj[twist][fsym] * N_COMB
						+ CCombConj[tsym][fsym], N_HUGE_5 * 4L);
			} else {
				prunm3 = getPruningP(UDSliceFlipTwistPrunP, flip * N_TWIST
						+ TwistConj[twist][fsym], N_FULL_5 * 4);
			}
			prun = ((0x49249249 << prunm3 >> cc.prun) & 3) + cc.prun - 1;
		} else {
			slice = UDSliceMove[cc.slice & 0x1ff][m] & 0x1ff;

			flip = FlipMove[cc.flip][CubieCube.Sym8Move[m << 3 | cc.fsym]];
			fsym = CubieCube.Sym8Mult[flip & 7 | cc.fsym << 3];
			flip >>= 3;

			twist = TwistMove[cc.twist][CubieCube.Sym8Move[m << 3 | cc.tsym]];
			tsym = CubieCube.Sym8Mult[twist & 7 | cc.tsym << 3];
			twist >>= 3;

			prun = Math.max(
					Math.max(
							getPruning(UDSliceTwistPrun, twist * N_SLICE
									+ UDSliceConj[slice][tsym]),
							getPruning(UDSliceFlipPrun, flip * N_SLICE
									+ UDSliceConj[slice][fsym])),
					Search.USE_TWIST_FLIP_PRUN ? getPruning(TwistFlipPrun,
							twist << 11
									| CubieCube.FlipS2RF[flip << 3
											| CubieCube.Sym8MultInv[fsym << 3
													| tsym]]) : 0);
		}
		return prun;
	}
}
\n
./src/main//java//com//example//rubikrobot//Solution//CubieCube.java
\n
package com.example.rubikrobot.Solution;

import java.util.Arrays;

class CubieCube {

    /**
     * 16 symmetries generated by S_F2, S_U4 and S_LR2
     */
    static CubieCube[] CubeSym = new CubieCube[16];

    /**
     * 18 move cubes
     */
    static CubieCube[] moveCube = new CubieCube[18];

    static long[] moveCubeSym = new long[18];
    static int[] firstMoveSym = new int[48];

    static int[] preMove = { -1, Util.Rx1, Util.Rx3, Util.Fx1, Util.Fx3, Util.Lx1, Util.Lx3, Util.Bx1, Util.Bx3};

    static int[] SymInv = new int[16];
    static int[][] SymMult = new int[16][16];
    static int[][] SymMove = new int[16][18];
    static int[][] SymMultInv = new int[16][16];
    static int[] Sym8Mult = new int[8 * 8];
    static int[] Sym8Move = new int[8 * 18];
    static int[] Sym8MultInv = new int[8 * 8];
    static int[][] SymMoveUD = new int[16][10];

    /**
     * ClassIndexToRepresentantArrays
     */
    static char[] FlipS2R = new char[336];
    static char[] TwistS2R = new char[324];
    static char[] EPermS2R = new char[2768];
    static int[] UDSliceFlipS2R = Search.USE_FULL_PRUN ? new int[64430] : null;

    /**
     * Notice that Edge Perm Coordnate and Corner Perm Coordnate are the same symmetry structure.
     * So their ClassIndexToRepresentantArray are the same.
     * And when x is RawEdgePermCoordnate, y*16+k is SymEdgePermCoordnate, y*16+(k^e2c[k]) will
     * be the SymCornerPermCoordnate of the State whose RawCornerPermCoordnate is x.
     */
    static byte[] e2c = {0, 0, 0, 0, 1, 3, 1, 3, 1, 3, 1, 3, 0, 0, 0, 0};

    static char[] MtoEPerm = new char[40320];

    static int[] FlipSlice2UDSliceFlip = Search.USE_FULL_PRUN ? new int[CoordCube.N_FLIP_SYM * CoordCube.N_SLICE] : null;

    /**
     * Raw-Coordnate to Sym-Coordnate, only for speeding up initializaion.
     */
    static char[] FlipR2S;// = new char[2048];
    static char[] TwistR2S;// = new char[2187];
    static char[] EPermR2S;// = new char[40320];
    static char[] FlipS2RF = Search.USE_TWIST_FLIP_PRUN ? new char[336 * 8] : null;
    static char[] TwistS2RF = Search.USE_FULL_PRUN ? new char[324 * 8] : null;

    /**
     *
     */
    static char[] SymStateTwist = new char[324];
    static char[] SymStateFlip = new char[336];
    static char[] SymStatePerm = new char[2768];
    static char[] SymStateUDSliceFlip = Search.USE_FULL_PRUN ? new char[64430] : null;

    static CubieCube urf1 = new CubieCube(2531, 1373, 67026819, 1367);
    static CubieCube urf2 = new CubieCube(2089, 1906, 322752913, 2040);
    static byte[][] urfMove = new byte[][] {
        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17},
        {6, 7, 8, 0, 1, 2, 3, 4, 5, 15, 16, 17, 9, 10, 11, 12, 13, 14},
        {3, 4, 5, 6, 7, 8, 0, 1, 2, 12, 13, 14, 15, 16, 17, 9, 10, 11},
        {2, 1, 0, 5, 4, 3, 8, 7, 6, 11, 10, 9, 14, 13, 12, 17, 16, 15},
        {8, 7, 6, 2, 1, 0, 5, 4, 3, 17, 16, 15, 11, 10, 9, 14, 13, 12},
        {5, 4, 3, 8, 7, 6, 2, 1, 0, 14, 13, 12, 17, 16, 15, 11, 10, 9}
    };

    byte[] ca = {0, 1, 2, 3, 4, 5, 6, 7};
    byte[] ea = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22};
    CubieCube temps = null;

    CubieCube() {
    }

    CubieCube(int cperm, int twist, int eperm, int flip) {
        this.setCPerm(cperm);
        this.setTwist(twist);
        Util.setNPerm(ea, eperm, 12, true);
        this.setFlip(flip);
    }

    CubieCube(CubieCube c) {
        copy(c);
    }

    public boolean equalsCorn(CubieCube c) {
        for (int i = 0; i < 8; i++) {
            if (ca[i] != c.ca[i]) {
                return false;
            }
        }
        return true;
    }

    public boolean equalsEdge(CubieCube c) {
        for (int i = 0; i < 12; i++) {
            if (ea[i] != c.ea[i]) {
                return false;
            }
        }
        return true;
    }

    void copy(CubieCube c) {
        for (int i = 0; i < 8; i++) {
            this.ca[i] = c.ca[i];
        }
        for (int i = 0; i < 12; i++) {
            this.ea[i] = c.ea[i];
        }
    }

    void invCubieCube() {
        if (temps == null) {
            temps = new CubieCube();
        }
        for (byte edge = 0; edge < 12; edge++) {
            temps.ea[ea[edge] >> 1] = (byte) (edge << 1 | ea[edge] & 1);
        }
        for (byte corn = 0; corn < 8; corn++) {
            int ori = ca[corn] >> 3;
            ori = 4 >> ori & 3; //0->0, 1->2, 2->1
            temps.ca[ca[corn] & 0x7] = (byte) (corn | ori << 3);
        }
        copy(temps);
    }

    /**
     * prod = a * b, Corner Only.
     */
    static void CornMult(CubieCube a, CubieCube b, CubieCube prod) {
        for (int corn = 0; corn < 8; corn++) {
            int oriA = a.ca[b.ca[corn] & 7] >> 3;
            int oriB = b.ca[corn] >> 3;
            int ori = oriA;
            ori += (oriA < 3) ? oriB : 6 - oriB;
            ori %= 3;
            if ((oriA >= 3) ^ (oriB >= 3)) {
                ori += 3;
            }
            prod.ca[corn] = (byte) (a.ca[b.ca[corn] & 7] & 7 | ori << 3);
        }
    }

    /**
     * prod = a * b, Edge Only.
     */
    static void EdgeMult(CubieCube a, CubieCube b, CubieCube prod) {
        for (int ed = 0; ed < 12; ed++) {
            prod.ea[ed] = (byte) (a.ea[b.ea[ed] >> 1] ^ (b.ea[ed] & 1));
        }
    }

    /**
     * b = S_idx^-1 * a * S_idx, Corner Only.
     */
    static void CornConjugate(CubieCube a, int idx, CubieCube b) {
        CubieCube sinv = CubeSym[SymInv[idx]];
        CubieCube s = CubeSym[idx];
        for (int corn = 0; corn < 8; corn++) {
            int oriA = sinv.ca[a.ca[s.ca[corn] & 7] & 7] >> 3;
            int oriB = a.ca[s.ca[corn] & 7] >> 3;
            int ori = (oriA < 3) ? oriB : (3 - oriB) % 3;
            b.ca[corn] = (byte) (sinv.ca[a.ca[s.ca[corn] & 7] & 7] & 7 | ori << 3);
        }
    }

    /**
     * b = S_idx^-1 * a * S_idx, Edge Only.
     */
    static void EdgeConjugate(CubieCube a, int idx, CubieCube b) {
        CubieCube sinv = CubeSym[SymInv[idx]];
        CubieCube s = CubeSym[idx];
        for (int ed = 0; ed < 12; ed++) {
            b.ea[ed] = (byte) (sinv.ea[a.ea[s.ea[ed] >> 1] >> 1] ^ (a.ea[s.ea[ed] >> 1] & 1) ^ (s.ea[ed] & 1));
        }
    }

    /**
     * this = S_urf^-1 * this * S_urf.
     */
    void URFConjugate() {
        if (temps == null) {
            temps = new CubieCube();
        }
        CornMult(urf2, this, temps);
        CornMult(temps, urf1, this);
        EdgeMult(urf2, this, temps);
        EdgeMult(temps, urf1, this);
    }

    // ********************************************* Get and set coordinates *********************************************
    // XSym : Symmetry Coordnate of X. MUST be called after initialization of ClassIndexToRepresentantArrays.

    // ++++++++++++++++++++ Phase 1 Coordnates ++++++++++++++++++++
    // Flip : Orientation of 12 Edges. Raw[0, 2048) Sym[0, 336 * 8)
    // Twist : Orientation of 8 Corners. Raw[0, 2187) Sym[0, 324 * 8)
    // UDSlice : Positions of the 4 UDSlice edges, the order is ignored. [0, 495)

    int getFlip() {
        int idx = 0;
        for (int i = 0; i < 11; i++) {
            idx = idx << 1 | ea[i] & 1;
        }
        return idx;
    }

    void setFlip(int idx) {
        int parity = 0;
        for (int i = 10; i >= 0; i--) {
            int val = idx & 1;
            ea[i] = (byte) (ea[i] & 0xfe | val);
            parity ^= val;
            idx >>= 1;
        }
        ea[11] = (byte) (ea[11] & 0xfe | parity);
    }

    int getFlipSym() {
        if (FlipR2S != null) {
            return FlipR2S[getFlip()];
        }
        if (temps == null) {
            temps = new CubieCube();
        }
        for (int k = 0; k < 16; k += 2) {
            EdgeConjugate(this, SymInv[k], temps);
            int idx = Arrays.binarySearch(FlipS2R, (char) temps.getFlip());
            if (idx >= 0) {
                return idx << 3 | k >> 1;
            }
        }
        assert false;
        return 0;
    }

    int getTwist() {
        int idx = 0;
        for (int i = 0; i < 7; i++) {
            idx += (idx << 1) + (ca[i] >> 3);
        }
        return idx;
    }

    void setTwist(int idx) {
        int twst = 0;
        for (int i = 6; i >= 0; i--) {
            int val = idx % 3;
            ca[i] = (byte) (ca[i] & 0x7 | val << 3);
            twst += val;
            idx /= 3;
        }
        ca[7] = (byte) (ca[7] & 0x7 | ((15 - twst) % 3) << 3);
    }

    int getTwistSym() {
        if (TwistR2S != null) {
            return TwistR2S[getTwist()];
        }
        if (temps == null) {
            temps = new CubieCube();
        }
        for (int k = 0; k < 16; k += 2) {
            CornConjugate(this, SymInv[k], temps);
            int idx = Arrays.binarySearch(TwistS2R, (char) temps.getTwist());
            if (idx >= 0) {
                return idx << 3 | k >> 1;
            }
        }
        assert false;
        return 0;
    }

    int getUDSlice() {
        return Util.getComb(ea, 8, true);
    }

    void setUDSlice(int idx) {
        Util.setComb(ea, idx, 8, true);
    }

    int getU4Comb() {
        return Util.getComb(ea, 0, true);
    }

    int getD4Comb() {
        return Util.getComb(ea, 4, true);
    }

    // ++++++++++++++++++++ Phase 2 Coordnates ++++++++++++++++++++
    // EPerm : Permutations of 8 UD Edges. Raw[0, 40320) Sym[0, 2187 * 16)
    // Cperm : Permutations of 8 Corners. Raw[0, 40320) Sym[0, 2187 * 16)
    // MPerm : Permutations of 4 UDSlice Edges. [0, 24)

    int getCPerm() {
        return Util.get8Perm(ca, false);
    }

    void setCPerm(int idx) {
        Util.set8Perm(ca, idx, false);
    }

    int getCPermSym() {
        if (EPermR2S != null) {
            int idx = EPermR2S[getCPerm()];
            return idx ^ e2c[idx & 0xf];
        }
        if (temps == null) {
            temps = new CubieCube();
        }
        for (int k = 0; k < 16; k++) {
            CornConjugate(this, SymInv[k], temps);
            int idx = Arrays.binarySearch(EPermS2R, (char) temps.getCPerm());
            if (idx >= 0) {
                return idx << 4 | k;
            }
        }
        assert false;
        return 0;
    }

    int getEPerm() {
        return Util.get8Perm(ea, true);
    }

    void setEPerm(int idx) {
        Util.set8Perm(ea, idx, true);
    }

    int getEPermSym() {
        if (EPermR2S != null) {
            return EPermR2S[getEPerm()];
        }
        if (temps == null) {
            temps = new CubieCube();
        }
        for (int k = 0; k < 16; k++) {
            EdgeConjugate(this, SymInv[k], temps);
            int idx = Arrays.binarySearch(EPermS2R, (char) temps.getEPerm());
            if (idx >= 0) {
                return idx << 4 | k;
            }
        }
        return 0;
    }

    int getMPerm() {
        return Util.getComb(ea, 8, true) >> 9;
    }

    void setMPerm(int idx) {
        Util.setComb(ea, idx << 9, 8, true);
    }

    int getCComb() {
        return 69 - (Util.getComb(ca, 0, false) & 0x1ff);
    }

    void setCComb(int idx) {
        Util.setComb(ca, 69 - idx, 0, false);
    }

    /**
     * Check a cubiecube for solvability. Return the error code.
     * 0: Cube is solvable
     * -2: Not all 12 edges exist exactly once
     * -3: Flip error: One edge has to be flipped
     * -4: Not all corners exist exactly once
     * -5: Twist error: One corner has to be twisted
     * -6: Parity error: Two corners or two edges have to be exchanged
     */
    int verify() {
        int sum = 0;
        int edgeMask = 0;
        for (int e = 0; e < 12; e++) {
            edgeMask |= 1 << (ea[e] >> 1);
            sum ^= ea[e] & 1;
        }
        if (edgeMask != 0xfff) {
            return -2;// missing edges
        }
        if (sum != 0) {
            return -3;
        }
        int cornMask = 0;
        sum = 0;
        for (int c = 0; c < 8; c++) {
            cornMask |= 1 << (ca[c] & 7);
            sum += ca[c] >> 3;
        }
        if (cornMask != 0xff) {
            return -4;// missing corners
        }
        if (sum % 3 != 0) {
            return -5;// twisted corner
        }
        if ((Util.getNParity(Util.getNPerm(ea, 12, true), 12) ^ Util.getNParity(getCPerm(), 8)) != 0) {
            return -6;// parity error
        }
        return 0;// cube ok
    }

    long selfSymmetry() {
        CubieCube c = new CubieCube(this);
        CubieCube d = new CubieCube();
        long sym = 0L;
        for (int i = 0; i < 48; i++) {
            CornConjugate(c, SymInv[i % 16], d);
            if (d.equalsCorn(this)) {
                EdgeConjugate(c, SymInv[i % 16], d);
                if (d.equalsEdge(this)) {
                    sym |= 1L << i;
                }
            }
            if (i % 16 == 15) {
                c.URFConjugate();
            }
        }
        c.invCubieCube();
        for (int i = 0; i < 48; i++) {
            CornConjugate(c, SymInv[i % 16], d);
            if (d.equalsCorn(this)) {
                EdgeConjugate(c, SymInv[i % 16], d);
                if (d.equalsEdge(this)) {
                    sym |= 1L << 48;
                    break;
                }
            }
            if (i % 16 == 15) {
                c.URFConjugate();
            }
        }
        return sym;
    }

    void setUDSliceFlip(int idx) {
        setFlip(idx & 0x7ff);
        setUDSlice(idx >> 11);
    }

    int getUDSliceFlip() {
        return (getUDSlice() & 0x1ff) << 11 | getFlip();
    }

    int getUDSliceFlipSym() {
        int flip = getFlipSym();
        int fsym = flip & 0x7;
        flip >>= 3;
        int udslice = getUDSlice() & 0x1ff;
        int udsliceflip = FlipSlice2UDSliceFlip[flip * 495 + CoordCube.UDSliceConj[udslice][fsym]];
        return udsliceflip & 0xfffffff0 | SymMult[udsliceflip & 0xf][fsym << 1];
    }

    // ********************************************* Initialization functions *********************************************

    static void initMove() {
        moveCube[0] = new CubieCube(15120, 0, 119750400, 0);
        moveCube[3] = new CubieCube(21021, 1494, 323403417, 0);
        moveCube[6] = new CubieCube(8064, 1236, 29441808, 550);
        moveCube[9] = new CubieCube(9, 0, 5880, 0);
        moveCube[12] = new CubieCube(1230, 412, 2949660, 0);
        moveCube[15] = new CubieCube(224, 137, 328552, 137);
        for (int a = 0; a < 18; a += 3) {
            for (int p = 0; p < 2; p++) {
                moveCube[a + p + 1] = new CubieCube();
                EdgeMult(moveCube[a + p], moveCube[a], moveCube[a + p + 1]);
                CornMult(moveCube[a + p], moveCube[a], moveCube[a + p + 1]);
            }
        }
    }

    public String toString() {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < 8; i++) {
            sb.append("|" + (ca[i] & 7) + " " + (ca[i] >> 3));
        }
        sb.append("\n");
        for (int i = 0; i < 12; i++) {
            sb.append("|" + (ea[i] >> 1) + " " + (ea[i] & 1));
        }
        return sb.toString();
    }

    static void initSym() {
        CubieCube c = new CubieCube();
        CubieCube d = new CubieCube();
        CubieCube t;

        CubieCube f2 = new CubieCube(28783, 0, 259268407, 0);
        CubieCube u4 = new CubieCube(15138, 0, 119765538, 7);
        CubieCube lr2 = new CubieCube(5167, 0, 83473207, 0);
        for (int i = 0; i < 8; i++) {
            lr2.ca[i] |= 3 << 3;
        }

        for (int i = 0; i < 16; i++) {
            CubeSym[i] = new CubieCube(c);
            CornMult(c, u4, d);
            EdgeMult(c, u4, d);
            t = d;  d = c;  c = t;
            if (i % 4 == 3) {
                CornMult(c, lr2, d);
                EdgeMult(c, lr2, d);
                t = d;  d = c;  c = t;
            }
            if (i % 8 == 7) {
                CornMult(c, f2, d);
                EdgeMult(c, f2, d);
                t = d;  d = c;  c = t;
            }
        }
        for (int i = 0; i < 16; i++) {
            for (int j = 0; j < 16; j++) {
                CornMult(CubeSym[i], CubeSym[j], c);
                for (int k = 0; k < 16; k++) {
                    if (CubeSym[k].equalsCorn(c)) {
                        SymMult[i][j] = k;
                        if (k == 0) {
                            SymInv[i] = j;
                        }
                        break;
                    }
                }
            }
        }
        for (int j = 0; j < 18; j++) {
            for (int s = 0; s < 16; s++) {
                CornConjugate(moveCube[j], SymInv[s], c);
                for (int m = 0; m < 18; m++) {
                    if (c.equalsCorn(moveCube[m])) {
                        SymMove[s][j] = m;
                        break;
                    }
                }
            }
        }
        for (int s = 0; s < 16; s++) {
            for (int j = 0; j < 10; j++) {
                SymMoveUD[s][j] = Util.std2ud[SymMove[s][Util.ud2std[j]]];
            }
            for (int j = 0; j < 16; j++) {
                SymMultInv[j][s] = SymMult[j][SymInv[s]];
            }
        }
        for (int s = 0; s < 8; s++) {
            for (int j = 0; j < 8; j++) {
                Sym8Mult[s << 3 | j] = SymMult[j << 1][s << 1] >> 1;
                Sym8MultInv[j << 3 | s] = SymMult[j << 1][SymInv[s << 1]]>>1;
            }
            for (int j = 0; j < 18; j++) {
                Sym8Move[j << 3 | s] = SymMove[s << 1][j];
            }
        }
        for (int i = 0; i < 18; i++) {
            moveCubeSym[i] = moveCube[i].selfSymmetry();
        }
        for (int i = 0; i < 18; i++) {
            int j = i;
            for (int s = 0; s < 48; s++) {
                if (SymMove[s % 16][j] < i) {
                    firstMoveSym[s] |= 1 << i;
                }
                if (s % 16 == 15) {
                    j = urfMove[2][j];
                }
            }
        }
    }

    static void initFlipSym2Raw() {
        CubieCube c = new CubieCube();
        CubieCube d = new CubieCube();
        int count = 0;
        FlipR2S = new char[2048];
        for (int i = 0; i < 2048; i++) {
            if (FlipR2S[i] != 0) {
                continue;
            }
            c.setFlip(i);
            for (int s = 0; s < 16; s += 2) {
                EdgeConjugate(c, s, d);
                int idx = d.getFlip();
                if (idx == i) {
                    SymStateFlip[count] |= 1 << (s >> 1);
                }
                FlipR2S[idx] = (char) (count << 3 | s >> 1);
                if (Search.USE_TWIST_FLIP_PRUN) {
                    FlipS2RF[count << 3 | s >> 1] = (char) idx;
                }
            }
            FlipS2R[count++] = (char) i;
        }
        assert count == 336;
    }

    static void initTwistSym2Raw() {
        CubieCube c = new CubieCube();
        CubieCube d = new CubieCube();
        int count = 0;
        TwistR2S = new char[2187];
        for (int i = 0; i < 2187; i++) {
            if (TwistR2S[i] != 0) {
                continue;
            }
            c.setTwist(i);
            for (int s = 0; s < 16; s += 2) {
                CornConjugate(c, s, d);
                int idx = d.getTwist();
                if (idx == i) {
                    SymStateTwist[count] |= 1 << (s >> 1);
                }
                TwistR2S[idx] = (char) (count << 3 | s >> 1);
                if (Search.USE_FULL_PRUN) {
                    TwistS2RF[count << 3 | s >> 1] = (char) idx;
                }
            }
            TwistS2R[count++] = (char) i;
        }
        assert count == 324;
    }

    static byte[] Perm2Comb = new byte[2768];

    static void initPermSym2Raw() {
        CubieCube c = new CubieCube();
        CubieCube d = new CubieCube();
        int count = 0;
        EPermR2S = new char[40320];

        for (int i = 0; i < 40320; i++) {
            if (EPermR2S[i] != 0) {
                continue;
            }
            c.setEPerm(i);
            for (int s = 0; s < 16; s++) {
                EdgeConjugate(c, s, d);
                int idx = d.getEPerm();
                if (idx == i) {
                    SymStatePerm[count] |= 1 << s;
                }
                int a = d.getU4Comb();
                int b = d.getD4Comb() >> 9;
                int m = 494 - (a & 0x1ff) + (a >> 9) * 70 + b * 1680;
                MtoEPerm[m] = EPermR2S[idx] = (char) (count << 4 | s);
                if (s == 0) {
                    Perm2Comb[count] = (byte) (494 - (a & 0x1ff));
                }
            }
            EPermS2R[count++] = (char) i;
        }
        assert count == 2768;
    }

    static void initUDSliceFlipSym2Raw() {
        CubieCube c = new CubieCube();
        CubieCube d = new CubieCube();
        int[] occ = new int[2048 * 495 >> 5];
        int count = 0;
        for (int i = 0; i < 2048 * 495; i++) {
            if ((occ[i >> 5] & 1 << (i & 0x1f)) != 0) {
                continue;
            }
            c.setUDSliceFlip(i);
            for (int s = 0; s < 16; s++) {
                EdgeConjugate(c, s, d);
                int idx = d.getUDSliceFlip();
                if (idx == i) {
                    SymStateUDSliceFlip[count] |= 1 << s;
                }
                occ[idx >> 5] |= 1 << (idx & 0x1f);
                int fidx = Arrays.binarySearch(FlipS2R, (char) (idx & 0x7ff));
                if (fidx >= 0) {
                    FlipSlice2UDSliceFlip[fidx * CoordCube.N_SLICE + (idx >> 11)] = count << 4 | s;
                }
            }
            UDSliceFlipS2R[count++] = i;
        }
        assert count == 64430;
    }
}
\n
./src/main//java//com//example//rubikrobot//Solution//RubikRobot.java
\n
package com.example.rubikrobot.Solution;

import com.example.rubikrobot.InstructionOptimization.TrinaryTree;

/**
  * Created by Administrator on 2016/2/26.
  **/
public class RubikRobot {

    public static Search search=new Search();
    TrinaryTree trinarytree =new TrinaryTree();//对魔方复原算法得到的复原指令进行优化解析

    //将魔方复原指令按照自定义协议包装，开始字符为'#',结束字符为'!'
    public static String Change_chars(String solution)
    {
        String solution2=solution.replace(" ","");
        StringBuffer chars=new StringBuffer(solution2);
        //chars.insert(0,"#");
        //chars.insert(chars.length(),"!");
        return (chars.toString());
    }

    /*
     *在给定的时间内给出Kociemba算法最优解
     */
    public String Get_Solution(String chars,int mil_time)
    {
        int maxDepth=21;
        String min_rubik_solution=new String();
        int min_step=10000;
        int step;
        long t = System.nanoTime();
        String rubik_solution=search.solution(chars, maxDepth, 100, 0, 0);

        while (rubik_solution.startsWith("Error 8") && ((System.nanoTime() - t) <2* 1.0e9))
        {
            rubik_solution = search.next(100, 0, 0);
        }

        if(rubik_solution.contains("Error"))
           return "#Error!";

        long t2 = System.nanoTime();
        while((System.nanoTime()-t2)<mil_time*10e6&&(!rubik_solution.contains("Error")))
        {
                step=trinarytree.getStepNum_Equation(rubik_solution);
                if (step<min_step)
                {
                    min_step=step;
                    min_rubik_solution = rubik_solution;
                }
            rubik_solution=search.solution(chars, 21, 100, 0, 0);
        }
        return (trinarytree.Pack_Optim_Equation(Change_chars(min_rubik_solution)));
    }

    public String Get_Solution(String chars)
    {
        String rubik_solution=search.solution(chars,22,100,0,0);
        return (trinarytree.Pack_Optim_Equation(Change_chars(rubik_solution)));
    }

    //测试是否满足魔方解算公式的各种条件
    public String Test_Solution(String chars)
    {
        String rubik_solution=search.solution(chars,22,100,0,0);
        return rubik_solution;
    }


}
\n
./src/main//java//com//example//rubikrobot//Solution//Search.java
\n
package com.example.rubikrobot.Solution;


/**
 * Rubik's Cube Solver.<br>
 * A much faster and smaller implemention of Two-Phase Algorithm.<br>
 * Symmetry is used to reduce memory used.<br>
 * Total Memory used is about 1MB.<br>
 * @author Shuang Chen
 */
public class Search {

    public static final boolean USE_TWIST_FLIP_PRUN = true;
    public static final boolean USE_FULL_PRUN = false;
    public static final boolean USE_HUGE_PRUN = false;

    //Options for research purpose.
    static final boolean TRY_PRE_MOVE = true;
    static final boolean TRY_INVERSE = true;
    static final boolean TRY_THREE_AXES = true;
    static final int MAX_DEPTH2 = USE_FULL_PRUN ? 12 : 13;
    static final int PRE_IDX_MAX = TRY_PRE_MOVE ? 9 : 1;
    static boolean inited = false;
    
    private int[] move = new int[31];

    private int[][] corn0 = new int[6][PRE_IDX_MAX];
    private int[][] ud8e0 = new int[6][PRE_IDX_MAX];

    private CoordCube[] nodeUD = new CoordCube[21];
    private CoordCube[] nodeRL = new CoordCube[21];
    private CoordCube[] nodeFB = new CoordCube[21];

    private CoordCube[][] node0 = new CoordCube[6][PRE_IDX_MAX];

    private byte[] f = new byte[54];

    private long selfSym;
    private int preIdxMax;
    private int conjMask;
    private int urfIdx;
    private int preIdx;
    private int length1;
    private int depth1;
    private int maxDep2;
    private int sol;
    private String solution;
    private long probe;
    private long probeMax;
    private long probeMin;
    private int verbose;
    private CubieCube cc = new CubieCube();

    private boolean isRec = false;

    /**
     *     Verbose_Mask determines if a " . " separates the phase1 and phase2 parts of the solver string like in F' R B R L2 F .
     *     U2 U D for example.<br>
     */
    public static final int USE_SEPARATOR = 0x1;

    /**
     *     Verbose_Mask determines if the solution will be inversed to a scramble/state generator.
     */
    public static final int INVERSE_SOLUTION = 0x2;

    /**
     *     Verbose_Mask determines if a tag such as "(21f)" will be appended to the solution.
     */
    public static final int APPEND_LENGTH = 0x4;

    /**
     *     Verbose_Mask determines if guaranteeing the solution to be optimal.
     */
    public static final int OPTIMAL_SOLUTION = 0x8;


    public Search() {
        for (int i = 0; i < 21; i++) {
            nodeUD[i] = new CoordCube();
            nodeRL[i] = new CoordCube();
            nodeFB[i] = new CoordCube();
        }
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < PRE_IDX_MAX; j++) {
                node0[i][j] = new CoordCube();
            }
        }
    }

    /**
     * Computes the solver string for a given cube.
     *
     * @param facelets
     *      is the cube definition string format.<br>
     * The names of the facelet positions of the cube:
     * <pre>
     *             |************|
     *             |*U1**U2**U3*|
     *             |************|
     *             |*U4**U5**U6*|
     *             |************|
     *             |*U7**U8**U9*|
     *             |************|
     * ************|************|************|************|
     * *L1**L2**L3*|*F1**F2**F3*|*R1**R2**F3*|*B1**B2**B3*|
     * ************|************|************|************|
     * *L4**L5**L6*|*F4**F5**F6*|*R4**R5**R6*|*B4**B5**B6*|
     * ************|************|************|************|
     * *L7**L8**L9*|*F7**F8**F9*|*R7**R8**R9*|*B7**B8**B9*|
     * ************|************|************|************|
     *             |************|
     *             |*D1**D2**D3*|
     *             |************|
     *             |*D4**D5**D6*|
     *             |************|
     *             |*D7**D8**D9*|
     *             |************|
     * </pre>
     * A cube definition string "UBL..." means for example: In position U1 we have the U-color, in position U2 we have the
     * B-color, in position U3 we have the L color etc. For example, the "super flip" state is represented as <br>
     * <pre>UBULURUFURURFRBRDRFUFLFRFDFDFDLDRDBDLULBLFLDLBUBRBLBDB</pre>
     * and the state generated by "F U' F2 D' B U R' F' L D' R' U' L U B' D2 R' F U2 D2" can be represented as <br>
     * <pre>FBLLURRFBUUFBRFDDFUULLFRDDLRFBLDRFBLUUBFLBDDBUURRBLDDR</pre>
     * You can also use {@link cs.min2phase.Tools#fromScramble(String s)} to convert the scramble string to the
     * cube definition string.
     *
     * @param maxDepth
     *      defines the maximal allowed maneuver length. For random cubes, a maxDepth of 21 usually will return a
     *      solution in less than 0.02 seconds on average. With a maxDepth of 20 it takes about 0.1 seconds on average to find a
     *      solution, but it may take much longer for specific cubes.
     *
     * @param probeMax
     *      defines the maximum number of the probes of phase 2. If it does not return with a solution, it returns with
     *      an error code.
     *
     * @param probeMin
     *      defines the minimum number of the probes of phase 2. So, if a solution is found within given probes, the
     *      computing will continue to find shorter solution(s). Btw, if probeMin > probeMax, probeMin will be set to probeMax.
     *
     * @param verbose
     *      determins the format of the solution(s). see USE_SEPARATOR, INVERSE_SOLUTION, APPEND_LENGTH, OPTIMAL_SOLUTION
     *
     * @return The solution string or an error code:<br>
     *      Error 1: There is not exactly one facelet of each colour<br>
     *      Error 2: Not all 12 edges exist exactly once<br>
     *      Error 3: Flip error: One edge has to be flipped<br>
     *      Error 4: Not all corners exist exactly once<br>
     *      Error 5: Twist error: One corner has to be twisted<br>
     *      Error 6: Parity error: Two corners or two edges have to be exchanged<br>
     *      Error 7: No solution exists for the given maxDepth<br>
     *      Error 8: Probe limit exceeded, no solution within given probMax
     */
    public synchronized String solution(String facelets, int maxDepth, long probeMax, long probeMin, int verbose) {
     //   System.out.println(facelets+"这是facelets");
        int check = verify(facelets);
        if (check != 0) {
            return "Error " + Math.abs(check);
        }
        System.out.println(check+"这是check");
        this.sol = maxDepth + 1;
        this.probe = 0;
        this.probeMax = probeMax;
        this.probeMin = Math.min(probeMin, probeMax);
        this.verbose = verbose;
        this.solution = null;
        this.isRec = false;

        init();

        initSearch();
        System.out.println("sadasdasdasdasdasdasdasdas");

        return (verbose & OPTIMAL_SOLUTION) == 0 ? search() : searchopt();
    }

    private void initSearch() {
        conjMask = (TRY_INVERSE ? 0 : 0x38) | (TRY_THREE_AXES ? 0 : 0x36);
        CubieCube pc = new CubieCube();
        selfSym = cc.selfSymmetry();
        if (selfSym >> 48 != 0) {
            conjMask |= 0x38;
        }
        if ((selfSym >> 16 & 0xffff) != 0) {
            conjMask |= 0x12;
        }
        if ((selfSym >> 32 & 0xffff) != 0) {
            conjMask |= 0x24;
        }
        preIdxMax = conjMask > 7 ? 1 : PRE_IDX_MAX;
        for (int i = 0; i < 6; i++) {
            node0[i][0].set(cc);
            corn0[i][0] = cc.getCPermSym();
            ud8e0[i][0] = cc.getU4Comb() << 16 | cc.getD4Comb();
            if ((conjMask & 1 << i) == 0) {
                for (int j = 1; j < preIdxMax; j++) {
                    CubieCube.CornMult(CubieCube.moveCube[CubieCube.preMove[j]], cc, pc);
                    CubieCube.EdgeMult(CubieCube.moveCube[CubieCube.preMove[j]], cc, pc);
                    node0[i][j].set(pc);
                    corn0[i][j] = pc.getCPermSym();
                    ud8e0[i][j] = pc.getU4Comb() << 16 | pc.getD4Comb();
                }
            }
            cc.URFConjugate();
            if (i % 3 == 2) {
                cc.invCubieCube();
            }
        }
        selfSym = selfSym & 0xffffffffffffL;
    }

    public synchronized String next(long probeMax, long probeMin, int verbose) {
        this.probe = 0;
        this.probeMax = probeMax;
        this.probeMin = Math.min(probeMin, probeMax);
        this.solution = null;
        this.isRec = (this.verbose & OPTIMAL_SOLUTION) == (verbose & OPTIMAL_SOLUTION);
        this.verbose = verbose;
        return (verbose & OPTIMAL_SOLUTION) == 0 ? search() : searchopt();
    }

    public static boolean isInited() {
        return inited;
    }

    public long numberOfProbes() {
        return probe;
    }

    public int length() {
        return sol;
    }

    public synchronized static void init() {
        if (inited) {
            return;
        }
        CubieCube.initMove();
        CubieCube.initSym();
        CubieCube.initFlipSym2Raw();
        CubieCube.initTwistSym2Raw();
        CubieCube.initPermSym2Raw();

        CoordCube.initFlipMove();
        CoordCube.initTwistMove();
        CoordCube.initUDSliceMoveConj();

        CoordCube.initCPermMove();
        CoordCube.initEPermMove();
        CoordCube.initMPermMoveConj();
        CoordCube.initCombMoveConj();

        CoordCube.initMEPermPrun();
        CoordCube.initMCPermPrun();
        CoordCube.initPermCombPrun();

        if (USE_FULL_PRUN || USE_HUGE_PRUN) {
            CubieCube.initUDSliceFlipSym2Raw();
            CoordCube.initUDSliceFlipMove();
            CoordCube.initTwistMoveConj();
            CoordCube.initUDSliceFlipTwistPrun();
            if (USE_HUGE_PRUN) {
                CoordCube.initHugePrun();
            }
        } else {
            if (USE_TWIST_FLIP_PRUN) {
                CoordCube.initTwistFlipPrun();
            }
            CoordCube.initSliceTwistPrun();
            CoordCube.initSliceFlipPrun();
        }

        inited = true;
    }

    int verify(String facelets) {
        int count = 0x000000;
        try {
            String center = new String(
                new char[] {
                    facelets.charAt(Util.U5),
                    facelets.charAt(Util.R5),
                    facelets.charAt(Util.F5),
                    facelets.charAt(Util.D5),
                    facelets.charAt(Util.L5),
                    facelets.charAt(Util.B5)
                }
            );
            for (int i = 0; i < 54; i++) {
                f[i] = (byte) center.indexOf(facelets.charAt(i));
                if (f[i] == -1) {
                    return -1;
                }
                count += 1 << (f[i] << 2);
            }
        } catch (Exception e) {
            return -1;
        }
        if (count != 0x999999) {
            return -1;
        }
        Util.toCubieCube(f, cc);
        return cc.verify();
    }

    private String search() {
        for (length1 = isRec ? length1 : 0; length1 < sol; length1++) {
            maxDep2 = Math.min(MAX_DEPTH2, sol - length1);
            for (urfIdx = isRec ? urfIdx : 0; urfIdx < 6; urfIdx++) {
                if ((conjMask & 1 << urfIdx) != 0) {
                    continue;
                }
                for (preIdx = isRec ? preIdx : 0; preIdx < preIdxMax; preIdx++) {
                    if (preIdx != 0 && preIdx % 2 == 0) {
                        continue;
                    }
                    node0[urfIdx][preIdx].calcPruning(true);
                    int ssym = (int) (0xffff & selfSym);
                    if (preIdx != 0) {
                        ssym &= CubieCube.moveCubeSym[CubieCube.preMove[preIdx]];
                    }
                    depth1 = length1 - (preIdx == 0 ? 0 : 1);
                    if (node0[urfIdx][preIdx].prun <= depth1
                            && phase1(node0[urfIdx][preIdx], ssym, depth1, -1) == 0) {
                        return solution == null ? "Error 8" : solution;
                    }
                }
            }
        }
        return solution == null ? "Error 7" : solution;
    }

    /**
     * @return
     *      0: Found or Probe limit exceeded
     *      1: Try Next Power
     *      2: Try Next Axis
     */
    private int phase1(CoordCube node, long ssym, int maxl, int lm) {
        if (node.prun == 0 && maxl < 5) {
            if (maxl == 0) {
                int ret = initPhase2();
                if (ret == 0 || preIdx == 0) {
                    return ret;
                }
                preIdx++;
                ret = Math.min(initPhase2(), ret);
                preIdx--;
                return ret;
            } else {
                return 1;
            }
        }

        int skipMoves = 0;
        int i = 1;
        for (long s = ssym; (s >>= 1) != 0; i++) {
            if ((s & 1) == 1) {
                skipMoves |= CubieCube.firstMoveSym[i];
            }
        }

        for (int axis = 0; axis < 18; axis += 3) {
            if (axis == lm || axis == lm - 9
                    || (isRec && axis < move[depth1 - maxl] - 2)) {
                continue;
            }
            for (int power = 0; power < 3; power++) {
                int m = axis + power;

                if (isRec && m != move[depth1 - maxl]
                        || ssym != 1 && (skipMoves & 1 << m) != 0) {
                    continue;
                }

                int prun = nodeUD[maxl].doMovePrun(node, m, true);
                if (prun > maxl) {
                    break;
                } else if (prun == maxl) {
                    continue;
                }

                move[depth1 - maxl] = m;
                int ret = phase1(nodeUD[maxl], ssym & CubieCube.moveCubeSym[m], maxl - 1, axis);
                if (ret == 0) {
                    return 0;
                } else if (ret == 2) {
                    break;
                }
            }
        }
        return 1;
    }

    private String searchopt() {
        int maxprun1 = 0;
        int maxprun2 = 0;
        for (int i = 0; i < 6; i++) {
            node0[i][0].calcPruning(false);
            if (i < 3) {
                maxprun1 = Math.max(maxprun1, node0[i][0].prun);
            } else {
                maxprun2 = Math.max(maxprun2, node0[i][0].prun);
            }
        }
        urfIdx = maxprun2 > maxprun1 ? 3 : 0;
        preIdx = 0;
        for (length1 = isRec ? length1 : 0; length1 < sol; length1++) {
            CoordCube ud = node0[0 + urfIdx][0];
            CoordCube rl = node0[1 + urfIdx][0];
            CoordCube fb = node0[2 + urfIdx][0];

            if (ud.prun <= length1 && rl.prun <= length1 && fb.prun <= length1
                    && phase1opt(ud, rl, fb, selfSym, length1, -1) == 0) {
                return solution == null ? "Error 8" : solution;
            }
        }
        return solution == null ? "Error 7" : solution;
    }

    /**
     * @return
     *      0: Found or Probe limit exceeded
     *      1: Try Next Power
     *      2: Try Next Axis
     */
    private int phase1opt(CoordCube ud, CoordCube rl, CoordCube fb, long ssym, int maxl, int lm) {
        if (ud.prun == 0 && rl.prun == 0 && fb.prun == 0 && maxl < 5) {
            maxDep2 = maxl + 1;
            depth1 = length1 - maxl;
            return initPhase2() == 0 ? 0 : 1;
        }

        int skipMoves = 0;
        int i = 1;
        for (long s = ssym; (s >>= 1) != 0; i++) {
            if ((s & 1) == 1) {
                skipMoves |= CubieCube.firstMoveSym[i];
            }
        }

        for (int axis = 0; axis < 18; axis += 3) {
            if (axis == lm || axis == lm - 9 || (isRec && axis < move[length1 - maxl] - 2)) {
                continue;
            }
            for (int power = 0; power < 3; power++) {
                int m = axis + power;

                if (isRec && m != move[length1 - maxl]
                        || ssym != 1 && (skipMoves & 1 << m) != 0) {
                    continue;
                }

                // UD Axis
                int prun_ud = nodeUD[maxl].doMovePrun(ud, m, false);
                if (prun_ud > maxl) {
                    break;
                } else if (prun_ud == maxl) {
                    continue;
                }

                // RL Axis
                m = CubieCube.urfMove[2][m];

                int prun_rl = nodeRL[maxl].doMovePrun(rl, m, false);
                if (prun_rl > maxl) {
                    break;
                } else if (prun_rl == maxl) {
                    continue;
                }

                // FB Axis
                m = CubieCube.urfMove[2][m];

                int prun_fb = nodeFB[maxl].doMovePrun(fb, m, false);
                if (prun_ud == prun_rl && prun_rl == prun_fb && prun_fb != 0) {
                    prun_fb++;
                }

                if (prun_fb > maxl) {
                    break;
                } else if (prun_fb == maxl) {
                    continue;
                }

                m = CubieCube.urfMove[2][m];

                move[length1 - maxl] = m;
                int ret = phase1opt(nodeUD[maxl], nodeRL[maxl], nodeFB[maxl], ssym & CubieCube.moveCubeSym[m], maxl - 1, axis);
                if (ret == 0) {
                    return 0;
                } else if (ret == 2) {
                    break;
                }
            }
        }
        return 1;
    }

    /**
     * @return
     *      0: Found or Probe limit exceeded
     *      1: Try Next Power
     *      2: Try Next Axis
     */
    private int initPhase2() {
        isRec = false;
        if (probe >= (solution == null ? probeMax : probeMin)) {
            return 0;
        }
        ++probe;
        int cidx = corn0[urfIdx][preIdx] >> 4;
        int csym = corn0[urfIdx][preIdx] & 0xf;
        int mid = node0[urfIdx][preIdx].slice;
        for (int i = 0; i < depth1; i++) {
            int m = move[i];
            cidx = CoordCube.CPermMove[cidx][CubieCube.SymMove[csym][m]];
            csym = CubieCube.SymMult[cidx & 0xf][csym];
            cidx >>= 4;

            int cx = CoordCube.UDSliceMove[mid & 0x1ff][m];
            mid = Util.permMult[mid >> 9][cx >> 9] << 9 | cx & 0x1ff;
        }
        mid >>= 9;
        int prun = CoordCube.getPruning(CoordCube.MCPermPrun, cidx * 24 + CoordCube.MPermConj[mid][csym]);
        if (prun >= maxDep2) {
            return prun > maxDep2 ? 2 : 1;
        }

        int u4e = ud8e0[urfIdx][preIdx] >> 16;
        int d4e = ud8e0[urfIdx][preIdx] & 0xffff;
        for (int i = 0; i < depth1; i++) {
            int m = move[i];

            int cx = CoordCube.UDSliceMove[u4e & 0x1ff][m];
            u4e = Util.permMult[u4e >> 9][cx >> 9] << 9 | cx & 0x1ff;

            cx = CoordCube.UDSliceMove[d4e & 0x1ff][m];
            d4e = Util.permMult[d4e >> 9][cx >> 9] << 9 | cx & 0x1ff;
        }

        int edge = CubieCube.MtoEPerm[494 - (u4e & 0x1ff) + (u4e >> 9) * 70 + (d4e >> 9) * 1680];
        int esym = edge & 0xf;
        edge >>= 4;

        prun = Math.max(prun, Math.max(
                            CoordCube.getPruning(CoordCube.MEPermPrun,
                                    edge * 24 + CoordCube.MPermConj[mid][esym]),
                            CoordCube.getPruning(CoordCube.EPermCCombPrun,
                                    edge * 70 + CoordCube.CCombConj[CubieCube.Perm2Comb[cidx]][CubieCube.SymMultInv[esym][csym]])));

        if (prun >= maxDep2) {
            return prun > maxDep2 ? 2 : 1;
        }

        int lm = 10;
        if (depth1 >= 2 && move[depth1 - 1] / 3 % 3 == move[depth1 - 2] / 3 % 3) {
            lm = Util.std2ud[Math.max(move[depth1 - 1], move[depth1 - 2]) / 3 * 3 + 1];
        } else if (depth1 >= 1) {
            lm = Util.std2ud[move[depth1 - 1] / 3 * 3 + 1];
            if (move[depth1 - 1] > Util.Fx3) {
                lm = -lm;
            }
        }

        int depth2;
        for (depth2 = maxDep2 - 1; depth2 >= prun; depth2--) {
            int ret = phase2(edge, esym, cidx, csym, mid, depth2, depth1, lm);
            if (ret < 0) {
                break;
            }
            depth2 = depth2 - ret;
            sol = depth1 + depth2;
            if (preIdx != 0) {
                assert depth2 > 0; //If depth2 == 0, the solution is optimal. In this case, we won't try preScramble to find shorter solutions.
                int axisPre = Util.preMove[preIdx] / 3;
                int axisLast = move[sol - 1] / 3;
                if (axisPre == axisLast) {
                    int pow = (Util.preMove[preIdx] % 3 + move[sol - 1] % 3 + 1) % 4;
                    move[sol - 1] = axisPre * 3 + pow;
                } else if (depth2 > 1
                           && axisPre % 3 == axisLast % 3
                           && move[sol - 2] / 3 == axisPre) {
                    int pow = (Util.preMove[preIdx] % 3 + move[sol - 2] % 3 + 1) % 4;
                    move[sol - 2] = axisPre * 3 + pow;
                } else {
                    move[sol++] = Util.preMove[preIdx];
                }
            }
            solution = solutionToString();
        }

        if (depth2 != maxDep2 - 1) { //At least one solution has been found.
            maxDep2 = Math.min(MAX_DEPTH2, sol - length1);
            return probe >= probeMin ? 0 : 1;
        } else {
            return 1;
        }
    }

    //-1: no solution found
    // X: solution with X moves shorter than expectation. Hence, the length of the solution is  depth - X
    private int phase2(int eidx, int esym, int cidx, int csym, int mid, int maxl, int depth, int lm) {
        if (eidx == 0 && cidx == 0 && mid == 0) {
            return maxl;
        }
        for (int m = 0; m < 10; m++) {
            if (lm < 0 ? (m == -lm) : Util.ckmv2[lm][m]) {
                continue;
            }
            int midx = CoordCube.MPermMove[mid][m];
            int cidxx = CoordCube.CPermMove[cidx][CubieCube.SymMove[csym][Util.ud2std[m]]];
            int csymx = CubieCube.SymMult[cidxx & 0xf][csym];
            cidxx >>= 4;
            if (CoordCube.getPruning(CoordCube.MCPermPrun,
                                     cidxx * 24 + CoordCube.MPermConj[midx][csymx]) >= maxl) {
                continue;
            }
            int eidxx = CoordCube.EPermMove[eidx][CubieCube.SymMoveUD[esym][m]];
            int esymx = CubieCube.SymMult[eidxx & 0xf][esym];
            eidxx >>= 4;
            if (CoordCube.getPruning(CoordCube.EPermCCombPrun,
                                     eidxx * 70 + CoordCube.CCombConj[CubieCube.Perm2Comb[cidxx]][CubieCube.SymMultInv[esymx][csymx]]) >= maxl) {
                continue;
            }
            if (CoordCube.getPruning(CoordCube.MEPermPrun,
                                     eidxx * 24 + CoordCube.MPermConj[midx][esymx]) >= maxl) {
                continue;
            }
            int ret = phase2(eidxx, esymx, cidxx, csymx, midx, maxl - 1, depth + 1, (lm < 0 && m + lm == -5) ? -lm : m);
            if (ret >= 0) {
                move[depth] = Util.ud2std[m];
                return ret;
            }
        }
        return -1;
    }

    private String solutionToString() {
        StringBuffer sb = new StringBuffer();
        int urf = (verbose & INVERSE_SOLUTION) != 0 ? (urfIdx + 3) % 6 : urfIdx;
        if (urf < 3) {
            for (int s = 0; s < sol; s++) {
                if ((verbose & USE_SEPARATOR) != 0 && s == depth1) {
                    sb.append(".  ");
                }
                sb.append(Util.move2str[CubieCube.urfMove[urf][move[s]]]).append(' ');
            }
        } else {
            for (int s = sol - 1; s >= 0; s--) {
                sb.append(Util.move2str[CubieCube.urfMove[urf][move[s]]]).append(' ');
                if ((verbose & USE_SEPARATOR) != 0 && s == depth1) {
                    sb.append(".  ");
                }
            }
        }
        if ((verbose & APPEND_LENGTH) != 0) {
            sb.append("(").append(sol).append("f)");
        }
        return sb.toString();
    }
}
\n
./src/main//java//com//example//rubikrobot//Solution//test.java
\n
package com.example.rubikrobot.Solution;

import java.util.Random;
import java.io.*;


public class test {

    static void other() {
    }

    static int testOptimal(int maxl, int length, int[] arr, int lm, Search search, int verbose) {
        if (maxl == 0) {
            String sol = search.solution(Tools.fromScramble(arr), 100, 0, 0, verbose | Search.INVERSE_SOLUTION);
            while (sol.startsWith("Error") || search.length() > length) {
                if (sol.startsWith("Error") && !sol.startsWith("Error 8")) {
                    throw new RuntimeException(String.format("Cannot find the optimal solution: %s", sol));
                }
                sol = search.next(100, 0, verbose | Search.INVERSE_SOLUTION);
            }
            assert Tools.fromScramble(sol).equals(Tools.fromScramble(arr));
            return 1;
        }
        int ret = 0;
        for (int axis = 0; axis < 18; axis += 3) {
            if (axis == lm || axis == lm - 9) {
                continue;
            }
            for (int pow = 0; pow < 3; pow++) {
                arr[length] = axis + pow;
                ret += testOptimal(maxl - 1, length + 1, arr, axis, search, verbose);
            }
        }
        return ret;
    }

    static void testRandomOptimal(int length, Search search, Random gen, int verbose) {
        int[] arr = new int[length];
        for (int i = 0; i < length; i++) {
            int axis = 0;
            do {
                axis = gen.nextInt(6) * 3;
            } while (i != 0 && (axis == arr[i - 1] / 3 * 3 || axis == arr[i - 1] / 3 * 3 - 9));
            int pow = gen.nextInt(3);
            arr[i] = axis + pow;
        }
        String sol = search.solution(Tools.fromScramble(arr), 100, 0, 0, verbose | Search.INVERSE_SOLUTION);
        while (sol.startsWith("Error") || search.length() > length) {
            if (sol.startsWith("Error") && !sol.startsWith("Error 8")) {
                throw new RuntimeException(String.format("Cannot find the optimal solution: %s", sol));
            }
            sol = search.next(100, 0, verbose | Search.INVERSE_SOLUTION);
        }
        assert Tools.fromScramble(sol).equals(Tools.fromScramble(arr));
    }

    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("java -client test testValue [nSolves maxLength maxProbe minProbe verbose]");
            return;
        }
        int testValue = args.length < 1 ? 0 : Integer.parseInt(args[0]);
        int nSolves = args.length < 2 ? 1000 : Integer.parseInt(args[1]);
        int maxLength = args.length < 3 ? 21 : Integer.parseInt(args[2]);
        int probeMax = args.length < 4 ? 100000 : Integer.parseInt(args[3]);
        int probeMin = args.length < 5 ? 0 : Integer.parseInt(args[4]);
        int verbose = args.length < 6 ? 0 : Integer.parseInt(args[5]);

        long tm;
        if ((testValue & 0x01) != 0) {
            tm = System.nanoTime();
            other();
            System.out.println(System.nanoTime() - tm);
        }

        DataInputStream dis = null;
        if ((testValue & 0x02) != 0) {
            tm = System.nanoTime();
            try {
                dis = new DataInputStream(new BufferedInputStream(new FileInputStream("data")));
                Tools.initFrom(dis);
            } catch (Exception e) {
                dis = null;
                e.printStackTrace();
            }
            System.out.println(System.nanoTime() - tm);
        }
        if ((testValue & 0x04) != 0) {
            tm = System.nanoTime();
            if (dis == null) {
                DataOutputStream dos = null;
                try {
                    dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream("data")));
                    Tools.saveTo(dos);
                    dos.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            System.out.println(System.nanoTime() - tm);
        }

        tm = System.nanoTime();
        Search.init();
        if ((testValue & 0x08) != 0) {
            System.out.println(String.format("Initialization Time: %d ms\r", System.nanoTime() - tm));
        }

        Search search = new Search();
        String sol;
        if ((testValue & 0x10) != 0) {
            System.out.println("========== Selected Scramble Solving Test (Optimal Solver) ==========");
            String scr = Tools.fromScramble(new int[0]);
            System.out.println(String.format("IdCube Test: \"%s\"", search.solution(scr, 21, 100000, 0, Search.OPTIMAL_SOLUTION)));

            int n_test = 0;
            long curTime;
            final int MAX_OPT_ALL = 3;
            for (int length = 1; length <= MAX_OPT_ALL; length++) {
                System.out.print(String.format("%d-Move: ", length));
                curTime = System.nanoTime();
                n_test = testOptimal(length, 0, new int[length], -1, search, Search.OPTIMAL_SOLUTION);
                System.out.println(String.format("OK, All %d Cube(s) Solved Optimally. AvgTime: %1.3f ms.", n_test, (System.nanoTime() - curTime) / 1000000d / n_test));
            }

            final long MAX_TEST_TIME = 100000000;
            for (int length = MAX_OPT_ALL + 1; length < 15; length++) {
                System.out.print(String.format("%d-Move: ", length));
                Random gen0 = new Random(42L);
                Random gen = new Random();
                curTime = System.nanoTime();
                n_test = 0;
                while (System.nanoTime() - curTime < MAX_TEST_TIME) {
                    gen.setSeed(gen0.nextLong());
                    testRandomOptimal(length, search, gen, Search.OPTIMAL_SOLUTION);
                    ++n_test;
                }
                System.out.println(String.format("OK, %d Cube(s) Solved Optimally. AvgTime: %1.3f ms.", n_test, (System.nanoTime() - curTime) / 1000000d / n_test));
            }

            System.out.println("========== Selected Scramble Solving Test (Two-phase Solver) ==========");
            System.out.print("IdCube Test: \"");
            scr = Tools.fromScramble(new int[0]);
            System.out.print(search.solution(scr, 21, 100000, 0, Search.OPTIMAL_SOLUTION));
            System.out.println("\"");

            for (int length = 1; length <= MAX_OPT_ALL; length++) {
                System.out.print(String.format("%d-Move: ", length));
                curTime = System.nanoTime();
                n_test = testOptimal(length, 0, new int[length], -1, search, 0);
                System.out.println(String.format("OK, All %d Cube(s) Solved Optimally. AvgTime: %1.3f ms.", n_test, (System.nanoTime() - curTime) / 1000000d / n_test));
            }

            for (int length = MAX_OPT_ALL + 1; length < 15; length++) {
                System.out.print(String.format("%d-Move: ", length));
                Random gen0 = new Random(42L);
                Random gen = new Random();
                curTime = System.nanoTime();
                n_test = 0;
                while (System.nanoTime() - curTime < MAX_TEST_TIME) {
                    gen.setSeed(gen0.nextLong());
                    testRandomOptimal(length, search, gen, 0);
                    ++n_test;
                }
                System.out.println(String.format("OK, %d Cube(s) Solved Optimally. AvgTime: %1.3f ms.", n_test, (System.nanoTime() - curTime) / 1000000d / n_test));
            }

            System.out.print("SuperFlip: ");
            curTime = System.nanoTime();
            sol = search.solution(Tools.superFlip(), 20, 1000000000, 0, 0);
            while (sol.startsWith("Error") || search.length() > 20) {
                if (sol.startsWith("Error") && !sol.startsWith("Error 8")) {
                    throw new RuntimeException(String.format("Cannot find the optimal solution: %s", sol));
                }
                sol = search.next(100000, 0, 0);
            }
            System.out.println(String.format("OK:\n%s\nTime: %1.3f ms.", sol, (System.nanoTime() - curTime) / 1000000d));
            System.out.print("20-Depth: ");
            String[] depth20 = new String[] {
                "B2 L  B2 R' F' U' B' L  D' F' L  U  L2 B2 L' D2 B2 D2 R2 B2",
                "R  U2 R  D2 R2 B2 L' D' B' F  U  B' R' U2 L' D  R2 F' U2 L2",
                "D2 R2 F2 D2 F2 D2 R' F2 D' L2 R  B  L' F  U  R' B  F2 R2 F'",
                "D' F' U  B2 R2 F  R' U2 B' L  D  F  R  D2 R2 L2 D' R2 F2 D'",
                "U2 R2 F2 D' U  F2 U2 B  U  B' R  U' F  L  B  R' F  L2 D' B ",
                "D  B2 D' B2 R2 D' R2 U  L  R' D  B' D  R  F' D2 R2 U' F' R ",
                "B  D' L' F' L  F  B  U' D2 F' R2 B' U  F2 R' L  U2 R2 F2 B2",
                "U2 L' U2 F2 L' R  D2 L2 B' D2 L  F' R' U' L  U2 F' D' R  B ",
                "F' L  B2 R  U' B' L  U2 D' F  L' R2 U2 D2 B2 R2 D  R2 L2 F2",
                "U2 R2 D2 B  U2 B' F  D' B' R' D  U2 B2 F2 R' D' B  U' F' R2"
            };
            n_test = 10;
            curTime = System.nanoTime();
            for (int i = 0; i < depth20.length; i++) {
                sol = search.solution(Tools.fromScramble(depth20[i]), 20, 100000, 0, Search.INVERSE_SOLUTION);
                assert Tools.fromScramble(depth20[i]).equals(Tools.fromScramble(sol));
            }
            System.out.println(String.format("OK, Random %d Cube(s) Solved. AvgTime: %1.3f ms.", n_test, (System.nanoTime() - curTime) / 1000000d / n_test));
        }

        if ((testValue & 0x20) != 0) {
            System.out.println("========== Random Scramble Solving Test (Two-phase Solver) ==========");
            System.out.println(String.format("Solve Random %d Cubes:", nSolves));
            System.out.println(
                "MaxLength: " + maxLength + "\n" +
                "ProbeMax: " + probeMax + "\n" +
                "ProbeMin: " + probeMin + "\n" +
                "verbose: " + verbose);
            tm = System.nanoTime();
            int total = 0;
            int x = 0;
            //          System.out.print("Average Solving Time: - nanoSecond(s)\r");
            long minT = 1L << 62;
            long maxT = 0L;
            long totalTime = 0;
            Tools.setRandomSource(new Random(42L));
            int totalLength = 0;
            int[] lengthDis = new int[30];
            while (System.nanoTime() - tm < 6000000000000L && x < nSolves) {
                long curTime = System.nanoTime();
                String cube = Tools.randomCube();
                String s = search.solution(cube, maxLength, probeMax, probeMin, verbose);
                // if (s.length() > 63) {
                //     s = search.next(probeMax, 0, verbose);
                // }
                curTime = System.nanoTime() - curTime;
                totalTime += curTime;
                maxT = Math.max(maxT, curTime);
                minT = Math.min(minT, curTime);
                totalLength += search.length();
                lengthDis[search.length()]++;
                x++;
                System.out.print(String.format("%6d AvgT: %6.3f ms, MaxT: %8.3f ms, MinT: %6.3f ms, AvgL: %6.3f\r", x,
                                               (totalTime / 1000000d) / x, maxT / 1000000d, minT / 1000000d, totalLength / 1.0d / x));
            }
            System.out.println();
            System.out.println(x + " Random Cube(s) Solved");
            System.out.println("Length Distribution: ");
            for (int i = 0; i < 30; i++) {
                if (lengthDis[i] != 0) {
                    System.out.println(String.format("%2d: %d", i, lengthDis[i]));
                }
            }
        }
    }
}
\n
./src/main//java//com//example//rubikrobot//Solution//Tools.java
\n
package com.example.rubikrobot.Solution;//package cs.min2phase;

import java.util.Random;
import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;

/**
 * Some useful functions.
 */
public class Tools {

    private static Random gen = new Random();

    private static void read(char[] arr, DataInput in) throws IOException {
        for (int i = 0, len = arr.length; i < len; i++) {
            arr[i] = in.readChar();
        }
    }

    private static void read(int[] arr, DataInput in) throws IOException {
        for (int i = 0, len = arr.length; i < len; i++) {
            arr[i] = in.readInt();
        }
    }

    private static void read(char[][] arr, DataInput in) throws IOException {
        for (int i = 0, leng = arr.length; i < leng; i++) {
            for (int j = 0, len = arr[i].length; j < len; j++) {
                arr[i][j] = in.readChar();
            }
        }
    }

    private static void read(int[][] arr, DataInput in) throws IOException {
        for (int i = 0, leng = arr.length; i < leng; i++) {
            for (int j = 0, len = arr[i].length; j < len; j++) {
                arr[i][j] = in.readInt();
            }
        }
    }

    private static void write(char[] arr, DataOutput out) throws IOException {
        for (int i = 0, len = arr.length; i < len; i++) {
            out.writeChar(arr[i]);
        }
    }

    private static void write(int[] arr, DataOutput out) throws IOException {
        for (int i = 0, len = arr.length; i < len; i++) {
            out.writeInt(arr[i]);
        }
    }

    private static void write(char[][] arr, DataOutput out) throws IOException {
        for (int i = 0, leng = arr.length; i < leng; i++) {
            for (int j = 0, len = arr[i].length; j < len; j++) {
                out.writeChar(arr[i][j]);
            }
        }
    }

    private static void write(int[][] arr, DataOutput out) throws IOException {
        for (int i = 0, leng = arr.length; i < leng; i++) {
            for (int j = 0, len = arr[i].length; j < len; j++) {
                out.writeInt(arr[i][j]);
            }
        }
    }

    protected Tools() {}

    /**
     * initializing from cached tables(move table, pruning table, etc.)
     *
     * @param in
     *     Where to read tables.
     *
     * @see cs.min2phase.Tools#saveTo(DataOutput)
     */
    public static void initFrom(DataInput in) throws IOException {
        if (Search.inited) {
            return;
        }
        CubieCube.initMove();
        CubieCube.initSym();
        read(CubieCube.FlipS2R, in);
        read(CubieCube.TwistS2R, in);
        read(CubieCube.EPermS2R, in);
        read(CubieCube.MtoEPerm, in);
        in.readFully(CubieCube.Perm2Comb);
        read(CoordCube.TwistMove, in);
        read(CoordCube.FlipMove, in);
        read(CoordCube.UDSliceMove, in);
        read(CoordCube.UDSliceConj, in);
        read(CoordCube.CPermMove, in);
        read(CoordCube.EPermMove, in);
        read(CoordCube.MPermMove, in);
        read(CoordCube.MPermConj, in);
        read(CoordCube.CCombMove, in);
        read(CoordCube.CCombConj, in);
        read(CoordCube.MCPermPrun, in);
        read(CoordCube.MEPermPrun, in);
        read(CoordCube.EPermCCombPrun, in);
        if (Search.USE_FULL_PRUN) {
            read(CubieCube.UDSliceFlipS2R, in);
            read(CubieCube.TwistS2RF, in);
            read(CoordCube.TwistMoveF, in);
            read(CoordCube.TwistConj, in);
            read(CoordCube.UDSliceFlipMove, in);
            read(CubieCube.FlipSlice2UDSliceFlip, in);
            CoordCube.initUDSliceFlipTwistPrun();
        } else {
            read(CoordCube.UDSliceTwistPrun, in);
            read(CoordCube.UDSliceFlipPrun, in);
            if (Search.USE_TWIST_FLIP_PRUN) {
                read(CubieCube.FlipS2RF, in);
                read(CoordCube.TwistFlipPrun, in);
            }
        }
        Search.inited = true;
    }

    /**
     * cache tables (move tables, pruning table, etc.), and read it while initializing.
     *
     * @param out
     *     Where to cache tables.
     *
     * @see cs.min2phase.Tools#initFrom(DataInput)
     */
    public static void saveTo(DataOutput out) throws IOException {
        Search.init();
        write(CubieCube.FlipS2R, out);                  //          672
        write(CubieCube.TwistS2R, out);                 // +        648
        write(CubieCube.EPermS2R, out);                 // +      5,536
        write(CubieCube.MtoEPerm, out);                 // +     80,640
        out.write(CubieCube.Perm2Comb);                 // +      2,768
        write(CoordCube.TwistMove, out);                // +     11,664
        write(CoordCube.FlipMove, out);                 // +     12,096
        write(CoordCube.UDSliceMove, out);              // +     17,820
        write(CoordCube.UDSliceConj, out);              // +      7,920
        write(CoordCube.CPermMove, out);                // +     99,648
        write(CoordCube.EPermMove, out);                // +     55,360
        write(CoordCube.MPermMove, out);                // +        480
        write(CoordCube.MPermConj, out);                // +        768
        write(CoordCube.CCombMove, out);                // +      1,400
        write(CoordCube.CCombConj, out);                // +      2,240
        write(CoordCube.MCPermPrun, out);               // +     33,216
        write(CoordCube.MEPermPrun, out);               // +     33,216
        write(CoordCube.EPermCCombPrun, out);           // +     96,880
        if (Search.USE_FULL_PRUN) {
            write(CubieCube.UDSliceFlipS2R, out);       // +    257,720
            write(CubieCube.TwistS2RF, out);            // +      5,184
            write(CoordCube.TwistMoveF, out);
            write(CoordCube.TwistConj, out);            // +     69,984
            write(CoordCube.UDSliceFlipMove, out);
            write(CubieCube.FlipSlice2UDSliceFlip, out);// +    665,280
        } else {                                        //
            write(CoordCube.UDSliceTwistPrun, out);     // +     80,192
            write(CoordCube.UDSliceFlipPrun, out);      // +     83,160
            if (Search.USE_TWIST_FLIP_PRUN) {           // =    626,324 Bytes
                write(CubieCube.FlipS2RF, out);         // +      5,376
                write(CoordCube.TwistFlipPrun, out);    // +    331,776
            }                                           // =    963,476 Bytes
        }
    }

    /**
     * Set Random Source.
     * @param gen new random source.
     */
    public static void setRandomSource(Random gen) {
        Tools.gen = gen;
    }

    /**
     * Generates a random cube.<br>
     *
     * The random source can be set by {@link cs.min2phase.Tools#setRandomSource(Random)}
     *
     * @return A random cube in the string representation. Each cube of the cube space has almost (depends on randomSource) the same probability.
     *
     * @see cs.min2phase.Tools#setRandomSource(Random)
     * @see cs.min2phase.Search#solution(String facelets, int maxDepth, long timeOut, long timeMin, int verbose)
     */
    public static String randomCube() {
        return randomState(STATE_RANDOM, STATE_RANDOM, STATE_RANDOM, STATE_RANDOM);
    }

    private static int resolveOri(byte[] arr, int base) {
        int sum = 0, idx = 0, lastUnknown = -1;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == -1) {
                arr[i] = (byte) gen.nextInt(base);
                lastUnknown = i;
            }
            sum += arr[i];
        }
        if (sum % base != 0 && lastUnknown != -1) {
            arr[lastUnknown] = (byte) ((30 + arr[lastUnknown] - sum) % base);
        }
        for (int i = 0; i < arr.length - 1; i++) {
            idx *= base;
            idx += arr[i];
        }
        return idx;
    }

    private static int countUnknown(byte[] arr) {
        if (arr == STATE_SOLVED) {
            return 0;
        }
        int cnt = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == -1) {
                cnt++;
            }
        }
        return cnt;
    }

    private static int resolvePerm(byte[] arr, int cntU, int parity) {
        if (arr == STATE_SOLVED) {
            return 0;
        } else if (arr == STATE_RANDOM) {
            return parity == -1 ? gen.nextInt(2) : parity;
        }
        byte[] val = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != -1) {
                val[arr[i]] = -1;
            }
        }
        int idx = 0;
        for (int i = 0; i < arr.length; i++) {
            if (val[i] != -1) {
                int j = gen.nextInt(idx + 1);
                byte temp = val[i];
                val[idx++] = val[j];
                val[j] = temp;
            }
        }
        int last = -1;
        for (idx = 0; idx < arr.length && cntU > 0; idx++) {
            if (arr[idx] == -1) {
                if (cntU == 2) {
                    last = idx;
                }
                arr[idx] = val[--cntU];
            }
        }
        int p = Util.getNParity(getNPerm(arr, arr.length), arr.length);
        if (p == 1 - parity && last != -1) {
            byte temp = arr[idx - 1];
            arr[idx - 1] = arr[last];
            arr[last] = temp;
        }
        return p;
    }

    static int getNPerm(byte[] arr, int n) {
        int idx = 0;
        for (int i = 0; i < n; i++) {
            idx *= (n - i);
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[i]) {
                    idx++;
                }
            }
        }
        return idx;
    }

    protected static final byte[] STATE_RANDOM = null;
    protected static final byte[] STATE_SOLVED = new byte[0];

    protected static String randomState(byte[] cp, byte[] co, byte[] ep, byte[] eo) {
        int parity;
        int cntUE = ep == STATE_RANDOM ? 12 : countUnknown(ep);
        int cntUC = cp == STATE_RANDOM ? 8 : countUnknown(cp);
        int cpVal, epVal;
        if (cntUE < 2) {    //ep != STATE_RANDOM
            if (ep == STATE_SOLVED) {
                epVal = parity = 0;
            } else {
                parity = resolvePerm(ep, cntUE, -1);
                epVal = getNPerm(ep, 12);
            }
            if (cp == STATE_SOLVED) {
                cpVal = 0;
            } else if (cp == STATE_RANDOM) {
                do {
                    cpVal = gen.nextInt(40320);
                } while (Util.getNParity(cpVal, 8) != parity);
            } else {
                resolvePerm(cp, cntUC, parity);
                cpVal = getNPerm(cp, 8);
            }
        } else {    //ep != STATE_SOLVED
            if (cp == STATE_SOLVED) {
                cpVal = parity = 0;
            } else if (cp == STATE_RANDOM) {
                cpVal = gen.nextInt(40320);
                parity = Util.getNParity(cpVal, 8);
            } else {
                parity = resolvePerm(cp, cntUC, -1);
                cpVal = getNPerm(cp, 8);
            }
            if (ep == STATE_RANDOM) {
                do {
                    epVal = gen.nextInt(479001600);
                } while (Util.getNParity(epVal, 12) != parity);
            } else {
                resolvePerm(ep, cntUE, parity);
                epVal = getNPerm(ep, 12);
            }
        }
        return Util.toFaceCube(
                   new CubieCube(
                       cpVal,
                       co == STATE_RANDOM ? gen.nextInt(2187) : (co == STATE_SOLVED ? 0 : resolveOri(co, 3)),
                       epVal,
                       eo == STATE_RANDOM ? gen.nextInt(2048) : (eo == STATE_SOLVED ? 0 : resolveOri(eo, 2))));
    }


    public static String randomLastLayer() {
        return randomState(
                   new byte[] { -1, -1, -1, -1, 4, 5, 6, 7},
                   new byte[] { -1, -1, -1, -1, 0, 0, 0, 0},
                   new byte[] { -1, -1, -1, -1, 4, 5, 6, 7, 8, 9, 10, 11},
                   new byte[] { -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0});
    }

    public static String randomLastSlot() {
        return randomState(
                   new byte[] { -1, -1, -1, -1, -1, 5, 6, 7},
                   new byte[] { -1, -1, -1, -1, -1, 0, 0, 0},
                   new byte[] { -1, -1, -1, -1, 4, 5, 6, 7, -1, 9, 10, 11},
                   new byte[] { -1, -1, -1, -1, 0, 0, 0, 0, -1, 0, 0, 0});
    }

    public static String randomZBLastLayer() {
        return randomState(
                   new byte[] { -1, -1, -1, -1, 4, 5, 6, 7},
                   new byte[] { -1, -1, -1, -1, 0, 0, 0, 0},
                   new byte[] { -1, -1, -1, -1, 4, 5, 6, 7, 8, 9, 10, 11},
                   STATE_SOLVED);
    }

    public static String randomCornerOfLastLayer() {
        return randomState(
                   new byte[] { -1, -1, -1, -1, 4, 5, 6, 7},
                   new byte[] { -1, -1, -1, -1, 0, 0, 0, 0},
                   STATE_SOLVED,
                   STATE_SOLVED);
    }

    public static String randomEdgeOfLastLayer() {
        return randomState(
                   STATE_SOLVED,
                   STATE_SOLVED,
                   new byte[] { -1, -1, -1, -1, 4, 5, 6, 7, 8, 9, 10, 11},
                   new byte[] { -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0});
    }

    public static String randomCrossSolved() {
        return randomState(
                   STATE_RANDOM,
                   STATE_RANDOM,
                   new byte[] { -1, -1, -1, -1, 4, 5, 6, 7, -1, -1, -1, -1},
                   new byte[] { -1, -1, -1, -1, 0, 0, 0, 0, -1, -1, -1, -1});
    }

    public static String randomEdgeSolved() {
        return randomState(
                   STATE_RANDOM,
                   STATE_RANDOM,
                   STATE_SOLVED,
                   STATE_SOLVED);
    }

    public static String randomCornerSolved() {
        return randomState(
                   STATE_SOLVED,
                   STATE_SOLVED,
                   STATE_RANDOM,
                   STATE_RANDOM);
    }

    public static String superFlip() {
        return Util.toFaceCube(new CubieCube(0, 0, 0, 2047));
    }


    public static String fromScramble(int[] scramble) {
        CubieCube c1 = new CubieCube();
        CubieCube c2 = new CubieCube();
        CubieCube tmp;
        for (int i = 0; i < scramble.length; i++) {
            CubieCube.CornMult(c1, CubieCube.moveCube[scramble[i]], c2);
            CubieCube.EdgeMult(c1, CubieCube.moveCube[scramble[i]], c2);
            tmp = c1; c1 = c2; c2 = tmp;
        }
        return Util.toFaceCube(c1);
    }

    /**
     * Convert a scramble string to its cube definition string.
     *
     * @param s  scramble string. Only outer moves (U, R, F, D, L, B, U2, R2, ...) are recognized.
     * @return cube definition string, which represent the state generated by the scramble<br>
     */
    public static String fromScramble(String s) {
        int[] arr = new int[s.length()];
        int j = 0;
        int axis = -1;
        for (int i = 0, length = s.length(); i < length; i++) {
            switch (s.charAt(i)) {
            case 'U':   axis = 0;   break;
            case 'R':   axis = 3;   break;
            case 'F':   axis = 6;   break;
            case 'D':   axis = 9;   break;
            case 'L':   axis = 12;  break;
            case 'B':   axis = 15;  break;
            case ' ':
                if (axis != -1) {
                    arr[j++] = axis;
                }
                axis = -1;
                break;
            case '2':   axis++; break;
            case '\'':  axis += 2; break;
            default:    continue;
            }

        }
        if (axis != -1) arr[j++] = axis;
        int[] ret = new int[j];
        while (--j >= 0) {
            ret[j] = arr[j];
        }
        return fromScramble(ret);
    }

    /**
     * Check whether the cube definition string s represents a solvable cube.
     *
     * @param facelets is the cube definition string , see {@link cs.min2phase.Search#solution(String facelets, int maxDepth, long timeOut, long timeMin, int verbose)}
     * @return 0: Cube is solvable<br>
     *         -1: There is not exactly one facelet of each colour<br>
     *         -2: Not all 12 edges exist exactly once<br>
     *         -3: Flip error: One edge has to be flipped<br>
     *         -4: Not all 8 corners exist exactly once<br>
     *         -5: Twist error: One corner has to be twisted<br>
     *         -6: Parity error: Two corners or two edges have to be exchanged
     */
    public static int verify(String facelets) {
        return new Search().verify(facelets);
    }
}
\n
./src/main//java//com//example//rubikrobot//Solution//Util.java
\n
package com.example.rubikrobot.Solution;//package cs.min2phase;

class Util {
    /*  //Edges
        static final byte UR = 0;
        static final byte UF = 1;
        static final byte UL = 2;
        static final byte UB = 3;
        static final byte DR = 4;
        static final byte DF = 5;
        static final byte DL = 6;
        static final byte DB = 7;
        static final byte FR = 8;
        static final byte FL = 9;
        static final byte BL = 10;
        static final byte BR = 11;

        //Corners
        static final byte URF = 0;
        static final byte UFL = 1;
        static final byte ULB = 2;
        static final byte UBR = 3;
        static final byte DFR = 4;
        static final byte DLF = 5;
        static final byte DBL = 6;
        static final byte DRB = 7;
    */
    //Moves
    static final byte Ux1 = 0;
    static final byte Ux2 = 1;
    static final byte Ux3 = 2;
    static final byte Rx1 = 3;
    static final byte Rx2 = 4;
    static final byte Rx3 = 5;
    static final byte Fx1 = 6;
    static final byte Fx2 = 7;
    static final byte Fx3 = 8;
    static final byte Dx1 = 9;
    static final byte Dx2 = 10;
    static final byte Dx3 = 11;
    static final byte Lx1 = 12;
    static final byte Lx2 = 13;
    static final byte Lx3 = 14;
    static final byte Bx1 = 15;
    static final byte Bx2 = 16;
    static final byte Bx3 = 17;

    //Facelets
    static final byte U1 = 0;
    static final byte U2 = 1;
    static final byte U3 = 2;
    static final byte U4 = 3;
    static final byte U5 = 4;
    static final byte U6 = 5;
    static final byte U7 = 6;
    static final byte U8 = 7;
    static final byte U9 = 8;
    static final byte R1 = 9;
    static final byte R2 = 10;
    static final byte R3 = 11;
    static final byte R4 = 12;
    static final byte R5 = 13;
    static final byte R6 = 14;
    static final byte R7 = 15;
    static final byte R8 = 16;
    static final byte R9 = 17;
    static final byte F1 = 18;
    static final byte F2 = 19;
    static final byte F3 = 20;
    static final byte F4 = 21;
    static final byte F5 = 22;
    static final byte F6 = 23;
    static final byte F7 = 24;
    static final byte F8 = 25;
    static final byte F9 = 26;
    static final byte D1 = 27;
    static final byte D2 = 28;
    static final byte D3 = 29;
    static final byte D4 = 30;
    static final byte D5 = 31;
    static final byte D6 = 32;
    static final byte D7 = 33;
    static final byte D8 = 34;
    static final byte D9 = 35;
    static final byte L1 = 36;
    static final byte L2 = 37;
    static final byte L3 = 38;
    static final byte L4 = 39;
    static final byte L5 = 40;
    static final byte L6 = 41;
    static final byte L7 = 42;
    static final byte L8 = 43;
    static final byte L9 = 44;
    static final byte B1 = 45;
    static final byte B2 = 46;
    static final byte B3 = 47;
    static final byte B4 = 48;
    static final byte B5 = 49;
    static final byte B6 = 50;
    static final byte B7 = 51;
    static final byte B8 = 52;
    static final byte B9 = 53;

    //Colors
    static final byte U = 0;
    static final byte R = 1;
    static final byte F = 2;
    static final byte D = 3;
    static final byte L = 4;
    static final byte B = 5;

    static final byte[][] cornerFacelet = {
        { U9, R1, F3 }, { U7, F1, L3 }, { U1, L1, B3 }, { U3, B1, R3 },
        { D3, F9, R7 }, { D1, L9, F7 }, { D7, B9, L7 }, { D9, R9, B7 }
    };
    static final byte[][] edgeFacelet = {
        { U6, R2 }, { U8, F2 }, { U4, L2 }, { U2, B2 }, { D6, R8 }, { D2, F8 },
        { D4, L8 }, { D8, B8 }, { F6, R4 }, { F4, L6 }, { B6, L4 }, { B4, R6 }
    };

    static int[][] Cnk = new int[13][13];
    static int[] fact = new int[14];
    static int[][] permMult = new int[24][24];
    static String[] move2str = {
        "U ", "U2", "U'", "R ", "R2", "R'", "F ", "F2", "F'",
        "D ", "D2", "D'", "L ", "L2", "L'", "B ", "B2", "B'"
    };
    static int[] preMove = { -1, Rx1, Rx3, Fx1, Fx3, Lx1, Lx3, Bx1, Bx3};
    static int[] ud2std = {Ux1, Ux2, Ux3, Rx2, Fx2, Dx1, Dx2, Dx3, Lx2, Bx2};
    static int[] std2ud = new int[18];
    static boolean[][] ckmv2 = new boolean[11][10];

    static void toCubieCube(byte[] f, CubieCube ccRet) {
        byte ori;
        for (int i = 0; i < 8; i++)
            ccRet.ca[i] = 0;// invalidate corners
        for (int i = 0; i < 12; i++)
            ccRet.ea[i] = 0;// and edges
        byte col1, col2;
        for (byte i = 0; i < 8; i++) {
            // get the colors of the cubie at corner i, starting with U/D
            for (ori = 0; ori < 3; ori++)
                if (f[cornerFacelet[i][ori]] == U || f[cornerFacelet[i][ori]] == D)
                    break;
            col1 = f[cornerFacelet[i][(ori + 1) % 3]];
            col2 = f[cornerFacelet[i][(ori + 2) % 3]];

            for (byte j = 0; j < 8; j++) {
                if (col1 == cornerFacelet[j][1] / 9 && col2 == cornerFacelet[j][2] / 9) {
                    // in cornerposition i we have cornercubie j
                    ccRet.ca[i] = (byte) (ori % 3 << 3 | j);
                    break;
                }
            }
        }
        for (byte i = 0; i < 12; i++) {
            for (byte j = 0; j < 12; j++) {
                if (f[edgeFacelet[i][0]] == edgeFacelet[j][0] / 9
                        && f[edgeFacelet[i][1]] == edgeFacelet[j][1] / 9) {
                    ccRet.ea[i] = (byte) (j << 1);
                    break;
                }
                if (f[edgeFacelet[i][0]] == edgeFacelet[j][1] / 9
                        && f[edgeFacelet[i][1]] == edgeFacelet[j][0] / 9) {
                    ccRet.ea[i] = (byte) (j << 1 | 1);
                    break;
                }
            }
        }
    }

    static String toFaceCube(CubieCube cc) {
        char[] f = new char[54];
        char[] ts = {'U', 'R', 'F', 'D', 'L', 'B'};
        for (int i = 0; i < 54; i++) {
            f[i] = ts[i / 9];
        }
        for (byte c = 0; c < 8; c++) {
            int j = cc.ca[c] & 0x7;// cornercubie with index j is at
            // cornerposition with index c
            int ori = cc.ca[c] >> 3;// Orientation of this cubie
            for (byte n = 0; n < 3; n++)
                f[cornerFacelet[c][(n + ori) % 3]] = ts[cornerFacelet[j][n] / 9];
        }
        for (byte e = 0; e < 12; e++) {
            int j = cc.ea[e] >> 1;// edgecubie with index j is at edgeposition
            // with index e
            int ori = cc.ea[e] & 1;// Orientation of this cubie
            for (byte n = 0; n < 2; n++)
                f[edgeFacelet[e][(n + ori) % 2]] = ts[edgeFacelet[j][n] / 9];
        }
        return new String(f);
    }

    static int getNParity(int idx, int n) {
        int p = 0;
        for (int i = n - 2; i >= 0; i--) {
            p ^= idx % (n - i);
            idx /= (n - i);
        }
        return p & 1;
    }

    static byte setVal(int val0, int val, boolean isEdge) {
        return (byte) (isEdge ? (val << 1 | val0 & 1) : (val | val0 & 0xf8));
    }

    static int getVal(int val0, boolean isEdge) {
        return isEdge ? val0 >> 1 : val0 & 7;
    }

    static void set8Perm(byte[] arr, int idx, boolean isEdge) {
        int val = 0x76543210;
        for (int i = 0; i < 7; i++) {
            int p = fact[7 - i];
            int v = idx / p;
            idx -= v * p;
            v <<= 2;
            arr[i] = setVal(arr[i], (val >> v & 0x7), isEdge);
            int m = (1 << v) - 1;
            val = val & m | val >> 4 & ~m;
        }
        arr[7] = setVal(arr[7], val, isEdge);
    }

    static int get8Perm(byte[] arr, boolean isEdge) {
        int idx = 0;
        int val = 0x76543210;
        for (int i = 0; i < 7; i++) {
            int v = getVal(arr[i], isEdge) << 2;
            idx = (8 - i) * idx + (val >> v & 0x7);
            val -= 0x11111110 << v;
        }
        return idx;
    }

    static void setNPerm(byte[] arr, int idx, int n, boolean isEdge) {
        arr[n - 1] = setVal(arr[n - 1], 0, isEdge);
        for (int i = n - 2; i >= 0; i--) {
            int arri = idx % (n - i);
            arr[i] = setVal(arr[i], arri, isEdge);
            idx /= (n - i);
            for (int j = i + 1; j < n; j++) {
                int arrj = getVal(arr[j], isEdge);
                if (arrj >= arri) {
                    arr[j] = setVal(arr[j], ++arrj, isEdge);
                }
            }
        }
    }

    static int getNPerm(byte[] arr, int n, boolean isEdge) {
        int idx = 0;
        for (int i = 0; i < n; i++) {
            idx *= (n - i);
            int arri = getVal(arr[i], isEdge);
            for (int j = i + 1; j < n; j++) {
                int arrj = getVal(arr[j], isEdge);
                if (arrj < arri) {
                    idx++;
                }
            }
        }
        return idx;
    }

    static int getComb(byte[] arr, int mask, boolean isEdge) {
        int end = arr.length - 1;
        int idxC = 0, idxP = 0, r = 4, val = 0x0123;
        for (int i = end; i >= 0; i--) {
            int perm = getVal(arr[i], isEdge);
            if ((perm & 0xc) == mask) {
                int v = (perm & 3) << 2;
                idxP = r * idxP + (val >> v & 0xf);
                val -= 0x0111 >> (12 - v);
                idxC += Cnk[i][r--];
            }
        }
        return idxP << 9 | Cnk[arr.length][4] - 1 - idxC;
    }

    static void setComb(byte[] arr, int idx, int mask, boolean isEdge) {
        int end = arr.length - 1;
        int r = 4, fill = end, val = 0x0123;
        int idxC = Cnk[arr.length][4] - 1 - (idx & 0x1ff);
        int idxP = idx >> 9;
        for (int i = end; i >= 0; i--) {
            if (idxC >= Cnk[i][r]) {
                idxC -= Cnk[i][r--];
                int p = fact[r];
                int v = idxP / p << 2;
                idxP %= p;
                arr[i] = setVal(arr[i], val >> v & 3 | mask, isEdge);
                int m = (1 << v) - 1;
                val = val & m | val >> 4 & ~m;
            } else {
                if ((fill & 0xc) == mask) {
                    fill -= 4;
                }
                arr[i] = setVal(arr[i], fill--, isEdge);
            }
        }
    }

    static {
        for (int i = 0; i < 10; i++) {
            std2ud[ud2std[i]] = i;
        }
        for (int i = 0; i < 10; i++) {
            int ix = ud2std[i];
            for (int j = 0; j < 10; j++) {
                int jx = ud2std[j];
                ckmv2[i][j] = (ix / 3 == jx / 3) || ((ix / 3 % 3 == jx / 3 % 3) && (ix >= jx));
            }
            ckmv2[10][i] = false;
        }
        fact[0] = 1;
        for (int i = 0; i < 13; i++) {
            Cnk[i][0] = Cnk[i][i] = 1;
            fact[i + 1] = fact[i] * (i + 1);
            for (int j = 1; j < i; j++) {
                Cnk[i][j] = Cnk[i - 1][j - 1] + Cnk[i - 1][j];
            }
        }
        byte[] arr1 = new byte[4];
        byte[] arr2 = new byte[4];
        byte[] arr3 = new byte[4];
        for (int i = 0; i < 24; i++) {
            setNPerm(arr1, i, 4, false);
            for (int j = 0; j < 24; j++) {
                setNPerm(arr2, j, 4, false);
                for (int k = 0; k < 4; k++) {
                    arr3[k] = arr1[arr2[k]];
                }
                permMult[i][j] = getNPerm(arr3, 4, false);
            }
        }
    }
}
\n
./src/test//java//com//example//rubikrobot//ExampleUnitTest.java
\n
package com.example.rubikrobot;

import org.junit.Test;

import static org.junit.Assert.*;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() {
        assertEquals(4, 2 + 2);
    }
}